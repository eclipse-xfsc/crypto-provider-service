// Code generated by goa v3.12.3, DO NOT EDIT.
//
// signer HTTP server types
//
// Command:
// $ goa gen github.com/eclipse-xfsc/crypto-provider-service/design

package server

import (
	signer "github.com/eclipse-xfsc/crypto-provider-service/deployment/docker/gen/signer"
	goa "goa.design/goa/v3/pkg"
)

// VerificationMethodRequestBody is the type of the "signer" service
// "VerificationMethod" endpoint HTTP request body.
type VerificationMethodRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine *string `form:"engine,omitempty" json:"engine,omitempty" xml:"engine,omitempty"`
}

// VerificationMethodsRequestBody is the type of the "signer" service
// "VerificationMethods" endpoint HTTP request body.
type VerificationMethodsRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine *string `form:"engine,omitempty" json:"engine,omitempty" xml:"engine,omitempty"`
}

// JwkPublicKeyRequestBody is the type of the "signer" service "JwkPublicKey"
// endpoint HTTP request body.
type JwkPublicKeyRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine *string `form:"engine,omitempty" json:"engine,omitempty" xml:"engine,omitempty"`
}

// CredentialProofRequestBody is the type of the "signer" service
// "CredentialProof" endpoint HTTP request body.
type CredentialProofRequestBody struct {
	// Key namespace.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
	// Key to use for the proof signature (optional).
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Verifiable Credential in JSON format or as sdjwt.
	Credential any `form:"credential,omitempty" json:"credential,omitempty" xml:"credential,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// identifies the format of the credential.
	Format *string `form:"format,omitempty" json:"format,omitempty" xml:"format,omitempty"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature.For sd-jwt is it automatically selected.
	SignatureType *string `form:"signatureType,omitempty" json:"signatureType,omitempty" xml:"signatureType,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
}

// PresentationProofRequestBody is the type of the "signer" service
// "PresentationProof" endpoint HTTP request body.
type PresentationProofRequestBody struct {
	// Issuer DID used to specify proof verification info.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
	// Key to use for the proof signature.
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Verifiable Presentation in JSON format.
	Presentation any `form:"presentation,omitempty" json:"presentation,omitempty" xml:"presentation,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature.For sd-jwt is it automatically selected.
	SignatureType *string `form:"signatureType,omitempty" json:"signatureType,omitempty" xml:"signatureType,omitempty"`
	// identifies the format of the credential.
	Format *string `form:"format,omitempty" json:"format,omitempty" xml:"format,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// audience
	Aud *string `form:"aud,omitempty" json:"aud,omitempty" xml:"aud,omitempty"`
}

// CreateCredentialRequestBody is the type of the "signer" service
// "CreateCredential" endpoint HTTP request body.
type CreateCredentialRequestBody struct {
	// Issuer DID of the Verifiable Credential.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
	// Key to use for the proof signature.
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Raw JSON that will be the VC subject.
	CredentialSubject any `form:"credentialSubject,omitempty" json:"credentialSubject,omitempty" xml:"credentialSubject,omitempty"`
	// Additional JSONLD contexts to be specified in the VC.
	Context []string `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// identifies the format of the credential.
	Format *string `form:"format,omitempty" json:"format,omitempty" xml:"format,omitempty"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Append Status
	Status *bool `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Type of signature. For sd-jwt is it automatically selected.
	SignatureType *string `form:"signatureType,omitempty" json:"signatureType,omitempty" xml:"signatureType,omitempty"`
	// Type(s) of the credential. Just first one for sd-jwt used.
	Type []string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// Holder Binding
	Holder *string `form:"holder,omitempty" json:"holder,omitempty" xml:"holder,omitempty"`
}

// CreatePresentationRequestBody is the type of the "signer" service
// "CreatePresentation" endpoint HTTP request body.
type CreatePresentationRequestBody struct {
	// Issuer DID of the Verifiable Presentation.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
	// Key to use for the proof signature.
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Raw JSON to be included inside the VP as Verifiable Credential.
	Data []any `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// Additional JSONLD contexts to be specified in the VP.
	Context []string `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature. For sd-jwt is it automatically selected.
	SignatureType *string `form:"signatureType,omitempty" json:"signatureType,omitempty" xml:"signatureType,omitempty"`
}

// VerifyCredentialRequestBody is the type of the "signer" service
// "VerifyCredential" endpoint HTTP request body.
type VerifyCredentialRequestBody struct {
	// Verifiable Credential in JSON format.
	Credential []byte `form:"credential,omitempty" json:"credential,omitempty" xml:"credential,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
}

// VerifyPresentationRequestBody is the type of the "signer" service
// "VerifyPresentation" endpoint HTTP request body.
type VerifyPresentationRequestBody struct {
	// Verifiable Presentation in JSON or sdjwt format.
	Presentation []byte `form:"presentation,omitempty" json:"presentation,omitempty" xml:"presentation,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// expected audience
	Aud *string `form:"aud,omitempty" json:"aud,omitempty" xml:"aud,omitempty"`
	// expected nonce
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
}

// SignRequestBody is the type of the "signer" service "Sign" endpoint HTTP
// request body.
type SignRequestBody struct {
	// Key namespace to be used for signing.
	Namespace *string `form:"namespace,omitempty" json:"namespace,omitempty" xml:"namespace,omitempty"`
	// Key to be used for signing.
	Key *string `form:"key,omitempty" json:"key,omitempty" xml:"key,omitempty"`
	// Data that must be signed, encoded as base64 string.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group *string `form:"group,omitempty" json:"group,omitempty" xml:"group,omitempty"`
}

// DidConfigurationRequestBody is the type of the "signer" service
// "DidConfiguration" endpoint HTTP request body.
type DidConfigurationRequestBody struct {
	// Type of signature
	XSignatureType *string `form:"x-signatureType,omitempty" json:"x-signatureType,omitempty" xml:"x-signatureType,omitempty"`
}

// VerificationMethodResponseBody is the type of the "signer" service
// "VerificationMethod" endpoint HTTP response body.
type VerificationMethodResponseBody struct {
	// ID of verification method.
	ID string `form:"id" json:"id" xml:"id"`
	// Type of verification method key.
	Type string `form:"type" json:"type" xml:"type"`
	// Controller of verification method specified as DID.
	Controller string `form:"controller" json:"controller" xml:"controller"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk" json:"publicKeyJwk" xml:"publicKeyJwk"`
}

// VerificationMethodsResponseBody is the type of the "signer" service
// "VerificationMethods" endpoint HTTP response body.
type VerificationMethodsResponseBody []*DIDVerificationMethodResponse

// VerifyCredentialResponseBody is the type of the "signer" service
// "VerifyCredential" endpoint HTTP response body.
type VerifyCredentialResponseBody struct {
	// Valid specifies if the proof is successfully verified.
	Valid bool `form:"valid" json:"valid" xml:"valid"`
	// Disclosed Credential
	DisclosedCredential any `form:"disclosedCredential,omitempty" json:"disclosedCredential,omitempty" xml:"disclosedCredential,omitempty"`
}

// VerifyPresentationResponseBody is the type of the "signer" service
// "VerifyPresentation" endpoint HTTP response body.
type VerifyPresentationResponseBody struct {
	// Valid specifies if the proof is successfully verified.
	Valid bool `form:"valid" json:"valid" xml:"valid"`
	// Disclosed Credential
	DisclosedCredential any `form:"disclosedCredential,omitempty" json:"disclosedCredential,omitempty" xml:"disclosedCredential,omitempty"`
}

// SignOKResponseBody is the type of the "signer" service "Sign" endpoint HTTP
// response body.
type SignOKResponseBody struct {
	// Signature encoded as base64 string.
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// DidDocOKResponseBody is the type of the "signer" service "didDoc" endpoint
// HTTP response body.
type DidDocOKResponseBody struct {
	// did of the document
	ID string `form:"id" json:"id" xml:"id"`
	// controler of the document
	Controller string `form:"controller" json:"controller" xml:"controller"`
	// methods of the document
	VerificationMethod []*DIDVerificationMethodResponseBody `form:"verificationMethod,omitempty" json:"verificationMethod,omitempty" xml:"verificationMethod,omitempty"`
	// serviceendpoints
	Service []*ServiceEndpointResponseBody `form:"service,omitempty" json:"service,omitempty" xml:"service,omitempty"`
}

// DidListOKResponseBody is the type of the "signer" service "didList" endpoint
// HTTP response body.
type DidListOKResponseBody struct {
	// did jwk list of keys
	List []*DidListResponseItemResponseBody `form:"list" json:"list" xml:"list"`
}

// JwksOKResponseBody is the type of the "signer" service "Jwks" endpoint HTTP
// response body.
type JwksOKResponseBody struct {
	// List of jwk
	Keys []any `form:"keys" json:"keys" xml:"keys"`
}

// DIDVerificationMethodResponse is used to define fields on response body
// types.
type DIDVerificationMethodResponse struct {
	// ID of verification method.
	ID string `form:"id" json:"id" xml:"id"`
	// Type of verification method key.
	Type string `form:"type" json:"type" xml:"type"`
	// Controller of verification method specified as DID.
	Controller string `form:"controller" json:"controller" xml:"controller"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk" json:"publicKeyJwk" xml:"publicKeyJwk"`
}

// DIDVerificationMethodResponseBody is used to define fields on response body
// types.
type DIDVerificationMethodResponseBody struct {
	// ID of verification method.
	ID string `form:"id" json:"id" xml:"id"`
	// Type of verification method key.
	Type string `form:"type" json:"type" xml:"type"`
	// Controller of verification method specified as DID.
	Controller string `form:"controller" json:"controller" xml:"controller"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk" json:"publicKeyJwk" xml:"publicKeyJwk"`
}

// ServiceEndpointResponseBody is used to define fields on response body types.
type ServiceEndpointResponseBody struct {
	// did of the document
	ID string `form:"id" json:"id" xml:"id"`
	// type of endpoint
	Type string `form:"type" json:"type" xml:"type"`
	// Endpoint URL
	ServiceEndpoint string `form:"serviceEndpoint" json:"serviceEndpoint" xml:"serviceEndpoint"`
}

// DidListResponseItemResponseBody is used to define fields on response body
// types.
type DidListResponseItemResponseBody struct {
	// name of the key.
	Name string `form:"name" json:"name" xml:"name"`
	// DID JWK of key
	Did string `form:"did" json:"did" xml:"did"`
}

// NewVerificationMethodResponseBody builds the HTTP response body from the
// result of the "VerificationMethod" endpoint of the "signer" service.
func NewVerificationMethodResponseBody(res *signer.DIDVerificationMethod) *VerificationMethodResponseBody {
	body := &VerificationMethodResponseBody{
		ID:           res.ID,
		Type:         res.Type,
		Controller:   res.Controller,
		PublicKeyJwk: res.PublicKeyJwk,
	}
	return body
}

// NewVerificationMethodsResponseBody builds the HTTP response body from the
// result of the "VerificationMethods" endpoint of the "signer" service.
func NewVerificationMethodsResponseBody(res []*signer.DIDVerificationMethod) VerificationMethodsResponseBody {
	body := make([]*DIDVerificationMethodResponse, len(res))
	for i, val := range res {
		body[i] = marshalSignerDIDVerificationMethodToDIDVerificationMethodResponse(val)
	}
	return body
}

// NewVerifyCredentialResponseBody builds the HTTP response body from the
// result of the "VerifyCredential" endpoint of the "signer" service.
func NewVerifyCredentialResponseBody(res *signer.VerifyResult) *VerifyCredentialResponseBody {
	body := &VerifyCredentialResponseBody{
		Valid:               res.Valid,
		DisclosedCredential: res.DisclosedCredential,
	}
	return body
}

// NewVerifyPresentationResponseBody builds the HTTP response body from the
// result of the "VerifyPresentation" endpoint of the "signer" service.
func NewVerifyPresentationResponseBody(res *signer.VerifyResult) *VerifyPresentationResponseBody {
	body := &VerifyPresentationResponseBody{
		Valid:               res.Valid,
		DisclosedCredential: res.DisclosedCredential,
	}
	return body
}

// NewSignOKResponseBody builds the HTTP response body from the result of the
// "Sign" endpoint of the "signer" service.
func NewSignOKResponseBody(res *signer.SignResult) *SignOKResponseBody {
	body := &SignOKResponseBody{
		Signature: res.Signature,
	}
	return body
}

// NewDidDocOKResponseBody builds the HTTP response body from the result of the
// "didDoc" endpoint of the "signer" service.
func NewDidDocOKResponseBody(res *signer.DidResponse) *DidDocOKResponseBody {
	body := &DidDocOKResponseBody{
		ID:         res.ID,
		Controller: res.Controller,
	}
	if res.VerificationMethod != nil {
		body.VerificationMethod = make([]*DIDVerificationMethodResponseBody, len(res.VerificationMethod))
		for i, val := range res.VerificationMethod {
			body.VerificationMethod[i] = marshalSignerDIDVerificationMethodToDIDVerificationMethodResponseBody(val)
		}
	}
	if res.Service != nil {
		body.Service = make([]*ServiceEndpointResponseBody, len(res.Service))
		for i, val := range res.Service {
			body.Service[i] = marshalSignerServiceEndpointToServiceEndpointResponseBody(val)
		}
	}
	return body
}

// NewDidListOKResponseBody builds the HTTP response body from the result of
// the "didList" endpoint of the "signer" service.
func NewDidListOKResponseBody(res *signer.DidListResponse) *DidListOKResponseBody {
	body := &DidListOKResponseBody{}
	if res.List != nil {
		body.List = make([]*DidListResponseItemResponseBody, len(res.List))
		for i, val := range res.List {
			body.List[i] = marshalSignerDidListResponseItemToDidListResponseItemResponseBody(val)
		}
	} else {
		body.List = []*DidListResponseItemResponseBody{}
	}
	return body
}

// NewJwksOKResponseBody builds the HTTP response body from the result of the
// "Jwks" endpoint of the "signer" service.
func NewJwksOKResponseBody(res *signer.JwksResponse) *JwksOKResponseBody {
	body := &JwksOKResponseBody{}
	if res.Keys != nil {
		body.Keys = make([]any, len(res.Keys))
		for i, val := range res.Keys {
			body.Keys[i] = val
		}
	} else {
		body.Keys = []any{}
	}
	return body
}

// NewNamespaceKeysRequest builds a signer service NamespaceKeys endpoint
// payload.
func NewNamespaceKeysRequest(namespace string, xGroup string) *signer.NamespaceKeysRequest {
	v := &signer.NamespaceKeysRequest{}
	v.Namespace = namespace
	v.XGroup = xGroup

	return v
}

// NewVerificationMethodRequest builds a signer service VerificationMethod
// endpoint payload.
func NewVerificationMethodRequest(body *VerificationMethodRequestBody, namespace string, key string, did string) *signer.VerificationMethodRequest {
	v := &signer.VerificationMethodRequest{}
	if body.Group != nil {
		v.Group = *body.Group
	}
	if body.Engine != nil {
		v.Engine = *body.Engine
	}
	if body.Group == nil {
		v.Group = ""
	}
	if body.Engine == nil {
		v.Engine = "transit"
	}
	v.Namespace = namespace
	v.Key = key
	v.Did = did

	return v
}

// NewVerificationMethodsRequest builds a signer service VerificationMethods
// endpoint payload.
func NewVerificationMethodsRequest(body *VerificationMethodsRequestBody, namespace string, did string) *signer.VerificationMethodsRequest {
	v := &signer.VerificationMethodsRequest{}
	if body.Group != nil {
		v.Group = *body.Group
	}
	if body.Engine != nil {
		v.Engine = *body.Engine
	}
	if body.Group == nil {
		v.Group = ""
	}
	if body.Engine == nil {
		v.Engine = "transit"
	}
	v.Namespace = namespace
	v.Did = did

	return v
}

// NewJwkPublicKeyRequest builds a signer service JwkPublicKey endpoint payload.
func NewJwkPublicKeyRequest(body *JwkPublicKeyRequestBody, namespace string, key string) *signer.JwkPublicKeyRequest {
	v := &signer.JwkPublicKeyRequest{
		Group: *body.Group,
	}
	if body.Engine != nil {
		v.Engine = *body.Engine
	}
	if body.Engine == nil {
		v.Engine = "transit"
	}
	v.Namespace = namespace
	v.Key = key

	return v
}

// NewCredentialProofRequest builds a signer service CredentialProof endpoint
// payload.
func NewCredentialProofRequest(body *CredentialProofRequestBody) *signer.CredentialProofRequest {
	v := &signer.CredentialProofRequest{
		Namespace:  *body.Namespace,
		Key:        *body.Key,
		Credential: body.Credential,
		Group:      *body.Group,
		Nonce:      body.Nonce,
	}
	if body.Format != nil {
		v.Format = *body.Format
	}
	if body.SignatureType != nil {
		v.SignatureType = *body.SignatureType
	}
	if body.Format == nil {
		v.Format = "ldp_vc"
	}
	if body.SignatureType == nil {
		v.SignatureType = "jsonwebsignature2020"
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}

	return v
}

// NewPresentationProofRequest builds a signer service PresentationProof
// endpoint payload.
func NewPresentationProofRequest(body *PresentationProofRequestBody) *signer.PresentationProofRequest {
	v := &signer.PresentationProofRequest{
		Issuer:       body.Issuer,
		Namespace:    *body.Namespace,
		Key:          *body.Key,
		Presentation: body.Presentation,
		Group:        *body.Group,
		Nonce:        body.Nonce,
		Aud:          body.Aud,
	}
	if body.SignatureType != nil {
		v.SignatureType = *body.SignatureType
	}
	if body.Format != nil {
		v.Format = *body.Format
	}
	if body.SignatureType == nil {
		v.SignatureType = "jsonwebsignature2020"
	}
	if body.Format == nil {
		v.Format = "ldp_vc"
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}

	return v
}

// NewCreateCredentialRequest builds a signer service CreateCredential endpoint
// payload.
func NewCreateCredentialRequest(body *CreateCredentialRequestBody, xOrigin string) *signer.CreateCredentialRequest {
	v := &signer.CreateCredentialRequest{
		Issuer:            body.Issuer,
		Namespace:         *body.Namespace,
		Key:               *body.Key,
		CredentialSubject: body.CredentialSubject,
		Group:             *body.Group,
		Nonce:             body.Nonce,
		Status:            body.Status,
		Holder:            body.Holder,
	}
	if body.Format != nil {
		v.Format = *body.Format
	}
	if body.SignatureType != nil {
		v.SignatureType = *body.SignatureType
	}
	if body.Context != nil {
		v.Context = make([]string, len(body.Context))
		for i, val := range body.Context {
			v.Context[i] = val
		}
	}
	if body.Format == nil {
		v.Format = "ldp_vc"
	}
	if body.SignatureType == nil {
		v.SignatureType = "jsonwebsignature2020"
	}
	if body.Type != nil {
		v.Type = make([]string, len(body.Type))
		for i, val := range body.Type {
			v.Type[i] = val
		}
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XOrigin = xOrigin

	return v
}

// NewCreatePresentationRequest builds a signer service CreatePresentation
// endpoint payload.
func NewCreatePresentationRequest(body *CreatePresentationRequestBody) *signer.CreatePresentationRequest {
	v := &signer.CreatePresentationRequest{
		Issuer:    body.Issuer,
		Namespace: *body.Namespace,
		Key:       *body.Key,
		Group:     *body.Group,
		Nonce:     body.Nonce,
	}
	if body.SignatureType != nil {
		v.SignatureType = *body.SignatureType
	}
	v.Data = make([]any, len(body.Data))
	for i, val := range body.Data {
		v.Data[i] = val
	}
	if body.Context != nil {
		v.Context = make([]string, len(body.Context))
		for i, val := range body.Context {
			v.Context[i] = val
		}
	}
	if body.SignatureType == nil {
		v.SignatureType = "jsonwebsignature2020"
	}

	return v
}

// NewVerifyCredentialRequest builds a signer service VerifyCredential endpoint
// payload.
func NewVerifyCredentialRequest(body *VerifyCredentialRequestBody, xFormat string, xNamespace *string, xGroup *string) *signer.VerifyCredentialRequest {
	v := &signer.VerifyCredentialRequest{
		Credential: body.Credential,
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XFormat = xFormat
	v.XNamespace = xNamespace
	v.XGroup = xGroup

	return v
}

// NewVerifyPresentationRequest builds a signer service VerifyPresentation
// endpoint payload.
func NewVerifyPresentationRequest(body *VerifyPresentationRequestBody, xFormat string) *signer.VerifyPresentationRequest {
	v := &signer.VerifyPresentationRequest{
		Presentation: body.Presentation,
		Aud:          body.Aud,
		Nonce:        body.Nonce,
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XFormat = xFormat

	return v
}

// NewSignRequest builds a signer service Sign endpoint payload.
func NewSignRequest(body *SignRequestBody) *signer.SignRequest {
	v := &signer.SignRequest{
		Namespace: *body.Namespace,
		Key:       *body.Key,
		Data:      *body.Data,
		Group:     *body.Group,
	}

	return v
}

// NewDidDocDidRequest builds a signer service didDoc endpoint payload.
func NewDidDocDidRequest(xNamespace string, xGroup string, xDid string, xEngine string) *signer.DidRequest {
	v := &signer.DidRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XDid = xDid
	v.XEngine = xEngine

	return v
}

// NewDidListRequest builds a signer service didList endpoint payload.
func NewDidListRequest(xNamespace string, xGroup string, xEngine string) *signer.DidListRequest {
	v := &signer.DidListRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XEngine = xEngine

	return v
}

// NewDidConfiguration2 builds a signer service DidConfiguration endpoint
// payload.
func NewDidConfiguration2(body *DidConfigurationRequestBody, xNamespace string, xGroup string, xOrigin string, xDid *string, xNonce *string) *signer.DidConfiguration2 {
	v := &signer.DidConfiguration2{}
	if body.XSignatureType != nil {
		v.XSignatureType = *body.XSignatureType
	}
	if body.XSignatureType == nil {
		v.XSignatureType = "jsonwebsignature2020"
	}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XOrigin = xOrigin
	v.XDid = xDid
	v.XNonce = xNonce

	return v
}

// NewJwksRequest builds a signer service Jwks endpoint payload.
func NewJwksRequest(xNamespace string, xGroup *string, xEngine string) *signer.JwksRequest {
	v := &signer.JwksRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XEngine = xEngine

	return v
}

// ValidateJwkPublicKeyRequestBody runs the validations defined on
// JwkPublicKeyRequestBody
func ValidateJwkPublicKeyRequestBody(body *JwkPublicKeyRequestBody) (err error) {
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	return
}

// ValidateCredentialProofRequestBody runs the validations defined on
// CredentialProofRequestBody
func ValidateCredentialProofRequestBody(body *CredentialProofRequestBody) (err error) {
	if body.Namespace == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("namespace", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Credential == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("credential", "body"))
	}
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	if body.Format != nil {
		if !(*body.Format == "ldp_vc" || *body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
	}
	if body.SignatureType != nil {
		if !(*body.SignatureType == "ed25519signature2020" || *body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", *body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
	}
	return
}

// ValidatePresentationProofRequestBody runs the validations defined on
// PresentationProofRequestBody
func ValidatePresentationProofRequestBody(body *PresentationProofRequestBody) (err error) {
	if body.Namespace == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("namespace", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Presentation == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("presentation", "body"))
	}
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	if body.SignatureType != nil {
		if !(*body.SignatureType == "ed25519signature2020" || *body.SignatureType == "jsonwebsignature2020" || *body.SignatureType == "sdjwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", *body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020", "sdjwt"}))
		}
	}
	if body.Format != nil {
		if !(*body.Format == "ldp_vc" || *body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
	}
	return
}

// ValidateCreateCredentialRequestBody runs the validations defined on
// CreateCredentialRequestBody
func ValidateCreateCredentialRequestBody(body *CreateCredentialRequestBody) (err error) {
	if body.Namespace == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("namespace", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.CredentialSubject == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("credentialSubject", "body"))
	}
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	if body.Format != nil {
		if !(*body.Format == "ldp_vc" || *body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", *body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
	}
	if body.SignatureType != nil {
		if !(*body.SignatureType == "ed25519signature2020" || *body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", *body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
	}
	return
}

// ValidateCreatePresentationRequestBody runs the validations defined on
// CreatePresentationRequestBody
func ValidateCreatePresentationRequestBody(body *CreatePresentationRequestBody) (err error) {
	if body.Namespace == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("namespace", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	if body.SignatureType != nil {
		if !(*body.SignatureType == "ed25519signature2020" || *body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", *body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
	}
	return
}

// ValidateVerifyCredentialRequestBody runs the validations defined on
// VerifyCredentialRequestBody
func ValidateVerifyCredentialRequestBody(body *VerifyCredentialRequestBody) (err error) {
	if body.Credential == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("credential", "body"))
	}
	return
}

// ValidateVerifyPresentationRequestBody runs the validations defined on
// VerifyPresentationRequestBody
func ValidateVerifyPresentationRequestBody(body *VerifyPresentationRequestBody) (err error) {
	if body.Presentation == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("presentation", "body"))
	}
	return
}

// ValidateSignRequestBody runs the validations defined on SignRequestBody
func ValidateSignRequestBody(body *SignRequestBody) (err error) {
	if body.Namespace == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("namespace", "body"))
	}
	if body.Key == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("key", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	if body.Group == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("group", "body"))
	}
	return
}

// ValidateDidConfigurationRequestBody runs the validations defined on
// DidConfigurationRequestBody
func ValidateDidConfigurationRequestBody(body *DidConfigurationRequestBody) (err error) {
	if body.XSignatureType != nil {
		if !(*body.XSignatureType == "ed25519signature2020" || *body.XSignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.x-signatureType", *body.XSignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
	}
	return
}
