// Code generated by goa v3.12.3, DO NOT EDIT.
//
// signer HTTP server
//
// Command:
// $ goa gen github.com/eclipse-xfsc/crypto-provider-service/design

package server

import (
	"context"
	"net/http"

	signer "github.com/eclipse-xfsc/crypto-provider-service/deployment/docker/gen/signer"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// Server lists the signer service endpoint HTTP handlers.
type Server struct {
	Mounts              []*MountPoint
	Namespaces          http.Handler
	NamespaceKeys       http.Handler
	VerificationMethod  http.Handler
	VerificationMethods http.Handler
	JwkPublicKey        http.Handler
	CredentialProof     http.Handler
	PresentationProof   http.Handler
	CreateCredential    http.Handler
	CreatePresentation  http.Handler
	VerifyCredential    http.Handler
	VerifyPresentation  http.Handler
	Sign                http.Handler
	DidDoc              http.Handler
	DidList             http.Handler
	DidConfiguration    http.Handler
	Jwks                http.Handler
}

// MountPoint holds information about the mounted endpoints.
type MountPoint struct {
	// Method is the name of the service method served by the mounted HTTP handler.
	Method string
	// Verb is the HTTP method used to match requests to the mounted handler.
	Verb string
	// Pattern is the HTTP request path pattern used to match requests to the
	// mounted handler.
	Pattern string
}

// New instantiates HTTP handlers for all the signer service endpoints using
// the provided encoder and decoder. The handlers are mounted on the given mux
// using the HTTP verb and path defined in the design. errhandler is called
// whenever a response fails to be encoded. formatter is used to format errors
// returned by the service methods prior to encoding. Both errhandler and
// formatter are optional and can be nil.
func New(
	e *signer.Endpoints,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) *Server {
	return &Server{
		Mounts: []*MountPoint{
			{"Namespaces", "GET", "/v1/namespaces"},
			{"NamespaceKeys", "GET", "/v1/namespaces/{namespace}/keys"},
			{"VerificationMethod", "GET", "/v1/verification-methods/{namespace}/{key}/{did}"},
			{"VerificationMethods", "GET", "/v1/verification-methods/{namespace}/{did}"},
			{"JwkPublicKey", "GET", "/v1/jwk/{namespace}/{key}"},
			{"CredentialProof", "POST", "/v1/credential/proof"},
			{"PresentationProof", "POST", "/v1/presentation/proof"},
			{"CreateCredential", "POST", "/v1/credential"},
			{"CreatePresentation", "POST", "/v1/presentation"},
			{"VerifyCredential", "POST", "/v1/credential/verify"},
			{"VerifyPresentation", "POST", "/v1/presentation/verify"},
			{"Sign", "POST", "/v1/sign"},
			{"DidDoc", "GET", "/v1/did/document"},
			{"DidList", "GET", "/v1/did/list"},
			{"DidConfiguration", "GET", "/v1/did/configuration"},
			{"Jwks", "GET", "/v1/jwks"},
		},
		Namespaces:          NewNamespacesHandler(e.Namespaces, mux, decoder, encoder, errhandler, formatter),
		NamespaceKeys:       NewNamespaceKeysHandler(e.NamespaceKeys, mux, decoder, encoder, errhandler, formatter),
		VerificationMethod:  NewVerificationMethodHandler(e.VerificationMethod, mux, decoder, encoder, errhandler, formatter),
		VerificationMethods: NewVerificationMethodsHandler(e.VerificationMethods, mux, decoder, encoder, errhandler, formatter),
		JwkPublicKey:        NewJwkPublicKeyHandler(e.JwkPublicKey, mux, decoder, encoder, errhandler, formatter),
		CredentialProof:     NewCredentialProofHandler(e.CredentialProof, mux, decoder, encoder, errhandler, formatter),
		PresentationProof:   NewPresentationProofHandler(e.PresentationProof, mux, decoder, encoder, errhandler, formatter),
		CreateCredential:    NewCreateCredentialHandler(e.CreateCredential, mux, decoder, encoder, errhandler, formatter),
		CreatePresentation:  NewCreatePresentationHandler(e.CreatePresentation, mux, decoder, encoder, errhandler, formatter),
		VerifyCredential:    NewVerifyCredentialHandler(e.VerifyCredential, mux, decoder, encoder, errhandler, formatter),
		VerifyPresentation:  NewVerifyPresentationHandler(e.VerifyPresentation, mux, decoder, encoder, errhandler, formatter),
		Sign:                NewSignHandler(e.Sign, mux, decoder, encoder, errhandler, formatter),
		DidDoc:              NewDidDocHandler(e.DidDoc, mux, decoder, encoder, errhandler, formatter),
		DidList:             NewDidListHandler(e.DidList, mux, decoder, encoder, errhandler, formatter),
		DidConfiguration:    NewDidConfigurationHandler(e.DidConfiguration, mux, decoder, encoder, errhandler, formatter),
		Jwks:                NewJwksHandler(e.Jwks, mux, decoder, encoder, errhandler, formatter),
	}
}

// Service returns the name of the service served.
func (s *Server) Service() string { return "signer" }

// Use wraps the server handlers with the given middleware.
func (s *Server) Use(m func(http.Handler) http.Handler) {
	s.Namespaces = m(s.Namespaces)
	s.NamespaceKeys = m(s.NamespaceKeys)
	s.VerificationMethod = m(s.VerificationMethod)
	s.VerificationMethods = m(s.VerificationMethods)
	s.JwkPublicKey = m(s.JwkPublicKey)
	s.CredentialProof = m(s.CredentialProof)
	s.PresentationProof = m(s.PresentationProof)
	s.CreateCredential = m(s.CreateCredential)
	s.CreatePresentation = m(s.CreatePresentation)
	s.VerifyCredential = m(s.VerifyCredential)
	s.VerifyPresentation = m(s.VerifyPresentation)
	s.Sign = m(s.Sign)
	s.DidDoc = m(s.DidDoc)
	s.DidList = m(s.DidList)
	s.DidConfiguration = m(s.DidConfiguration)
	s.Jwks = m(s.Jwks)
}

// MethodNames returns the methods served.
func (s *Server) MethodNames() []string { return signer.MethodNames[:] }

// Mount configures the mux to serve the signer endpoints.
func Mount(mux goahttp.Muxer, h *Server) {
	MountNamespacesHandler(mux, h.Namespaces)
	MountNamespaceKeysHandler(mux, h.NamespaceKeys)
	MountVerificationMethodHandler(mux, h.VerificationMethod)
	MountVerificationMethodsHandler(mux, h.VerificationMethods)
	MountJwkPublicKeyHandler(mux, h.JwkPublicKey)
	MountCredentialProofHandler(mux, h.CredentialProof)
	MountPresentationProofHandler(mux, h.PresentationProof)
	MountCreateCredentialHandler(mux, h.CreateCredential)
	MountCreatePresentationHandler(mux, h.CreatePresentation)
	MountVerifyCredentialHandler(mux, h.VerifyCredential)
	MountVerifyPresentationHandler(mux, h.VerifyPresentation)
	MountSignHandler(mux, h.Sign)
	MountDidDocHandler(mux, h.DidDoc)
	MountDidListHandler(mux, h.DidList)
	MountDidConfigurationHandler(mux, h.DidConfiguration)
	MountJwksHandler(mux, h.Jwks)
}

// Mount configures the mux to serve the signer endpoints.
func (s *Server) Mount(mux goahttp.Muxer) {
	Mount(mux, s)
}

// MountNamespacesHandler configures the mux to serve the "signer" service
// "Namespaces" endpoint.
func MountNamespacesHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/namespaces", f)
}

// NewNamespacesHandler creates a HTTP handler which loads the HTTP request and
// calls the "signer" service "Namespaces" endpoint.
func NewNamespacesHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		encodeResponse = EncodeNamespacesResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "Namespaces")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		var err error
		res, err := endpoint(ctx, nil)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountNamespaceKeysHandler configures the mux to serve the "signer" service
// "NamespaceKeys" endpoint.
func MountNamespaceKeysHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/namespaces/{namespace}/keys", f)
}

// NewNamespaceKeysHandler creates a HTTP handler which loads the HTTP request
// and calls the "signer" service "NamespaceKeys" endpoint.
func NewNamespaceKeysHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeNamespaceKeysRequest(mux, decoder)
		encodeResponse = EncodeNamespaceKeysResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "NamespaceKeys")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountVerificationMethodHandler configures the mux to serve the "signer"
// service "VerificationMethod" endpoint.
func MountVerificationMethodHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/verification-methods/{namespace}/{key}/{did}", f)
}

// NewVerificationMethodHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "VerificationMethod" endpoint.
func NewVerificationMethodHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeVerificationMethodRequest(mux, decoder)
		encodeResponse = EncodeVerificationMethodResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "VerificationMethod")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountVerificationMethodsHandler configures the mux to serve the "signer"
// service "VerificationMethods" endpoint.
func MountVerificationMethodsHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/verification-methods/{namespace}/{did}", f)
}

// NewVerificationMethodsHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "VerificationMethods" endpoint.
func NewVerificationMethodsHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeVerificationMethodsRequest(mux, decoder)
		encodeResponse = EncodeVerificationMethodsResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "VerificationMethods")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountJwkPublicKeyHandler configures the mux to serve the "signer" service
// "JwkPublicKey" endpoint.
func MountJwkPublicKeyHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/jwk/{namespace}/{key}", f)
}

// NewJwkPublicKeyHandler creates a HTTP handler which loads the HTTP request
// and calls the "signer" service "JwkPublicKey" endpoint.
func NewJwkPublicKeyHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeJwkPublicKeyRequest(mux, decoder)
		encodeResponse = EncodeJwkPublicKeyResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "JwkPublicKey")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCredentialProofHandler configures the mux to serve the "signer" service
// "CredentialProof" endpoint.
func MountCredentialProofHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/credential/proof", f)
}

// NewCredentialProofHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "CredentialProof" endpoint.
func NewCredentialProofHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCredentialProofRequest(mux, decoder)
		encodeResponse = EncodeCredentialProofResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CredentialProof")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountPresentationProofHandler configures the mux to serve the "signer"
// service "PresentationProof" endpoint.
func MountPresentationProofHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/presentation/proof", f)
}

// NewPresentationProofHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "PresentationProof" endpoint.
func NewPresentationProofHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodePresentationProofRequest(mux, decoder)
		encodeResponse = EncodePresentationProofResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "PresentationProof")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreateCredentialHandler configures the mux to serve the "signer"
// service "CreateCredential" endpoint.
func MountCreateCredentialHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/credential", f)
}

// NewCreateCredentialHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "CreateCredential" endpoint.
func NewCreateCredentialHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreateCredentialRequest(mux, decoder)
		encodeResponse = EncodeCreateCredentialResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreateCredential")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountCreatePresentationHandler configures the mux to serve the "signer"
// service "CreatePresentation" endpoint.
func MountCreatePresentationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/presentation", f)
}

// NewCreatePresentationHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "CreatePresentation" endpoint.
func NewCreatePresentationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeCreatePresentationRequest(mux, decoder)
		encodeResponse = EncodeCreatePresentationResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "CreatePresentation")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountVerifyCredentialHandler configures the mux to serve the "signer"
// service "VerifyCredential" endpoint.
func MountVerifyCredentialHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/credential/verify", f)
}

// NewVerifyCredentialHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "VerifyCredential" endpoint.
func NewVerifyCredentialHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeVerifyCredentialRequest(mux, decoder)
		encodeResponse = EncodeVerifyCredentialResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "VerifyCredential")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountVerifyPresentationHandler configures the mux to serve the "signer"
// service "VerifyPresentation" endpoint.
func MountVerifyPresentationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/presentation/verify", f)
}

// NewVerifyPresentationHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "VerifyPresentation" endpoint.
func NewVerifyPresentationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeVerifyPresentationRequest(mux, decoder)
		encodeResponse = EncodeVerifyPresentationResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "VerifyPresentation")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountSignHandler configures the mux to serve the "signer" service "Sign"
// endpoint.
func MountSignHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("POST", "/v1/sign", f)
}

// NewSignHandler creates a HTTP handler which loads the HTTP request and calls
// the "signer" service "Sign" endpoint.
func NewSignHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeSignRequest(mux, decoder)
		encodeResponse = EncodeSignResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "Sign")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDidDocHandler configures the mux to serve the "signer" service "didDoc"
// endpoint.
func MountDidDocHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/did/document", f)
}

// NewDidDocHandler creates a HTTP handler which loads the HTTP request and
// calls the "signer" service "didDoc" endpoint.
func NewDidDocHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDidDocRequest(mux, decoder)
		encodeResponse = EncodeDidDocResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "didDoc")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDidListHandler configures the mux to serve the "signer" service
// "didList" endpoint.
func MountDidListHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/did/list", f)
}

// NewDidListHandler creates a HTTP handler which loads the HTTP request and
// calls the "signer" service "didList" endpoint.
func NewDidListHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDidListRequest(mux, decoder)
		encodeResponse = EncodeDidListResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "didList")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountDidConfigurationHandler configures the mux to serve the "signer"
// service "DidConfiguration" endpoint.
func MountDidConfigurationHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/did/configuration", f)
}

// NewDidConfigurationHandler creates a HTTP handler which loads the HTTP
// request and calls the "signer" service "DidConfiguration" endpoint.
func NewDidConfigurationHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeDidConfigurationRequest(mux, decoder)
		encodeResponse = EncodeDidConfigurationResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "DidConfiguration")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}

// MountJwksHandler configures the mux to serve the "signer" service "Jwks"
// endpoint.
func MountJwksHandler(mux goahttp.Muxer, h http.Handler) {
	f, ok := h.(http.HandlerFunc)
	if !ok {
		f = func(w http.ResponseWriter, r *http.Request) {
			h.ServeHTTP(w, r)
		}
	}
	mux.Handle("GET", "/v1/jwks", f)
}

// NewJwksHandler creates a HTTP handler which loads the HTTP request and calls
// the "signer" service "Jwks" endpoint.
func NewJwksHandler(
	endpoint goa.Endpoint,
	mux goahttp.Muxer,
	decoder func(*http.Request) goahttp.Decoder,
	encoder func(context.Context, http.ResponseWriter) goahttp.Encoder,
	errhandler func(context.Context, http.ResponseWriter, error),
	formatter func(ctx context.Context, err error) goahttp.Statuser,
) http.Handler {
	var (
		decodeRequest  = DecodeJwksRequest(mux, decoder)
		encodeResponse = EncodeJwksResponse(encoder)
		encodeError    = goahttp.ErrorEncoder(encoder, formatter)
	)
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ctx := context.WithValue(r.Context(), goahttp.AcceptTypeKey, r.Header.Get("Accept"))
		ctx = context.WithValue(ctx, goa.MethodKey, "Jwks")
		ctx = context.WithValue(ctx, goa.ServiceKey, "signer")
		payload, err := decodeRequest(r)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		res, err := endpoint(ctx, payload)
		if err != nil {
			if err := encodeError(ctx, w, err); err != nil {
				errhandler(ctx, w, err)
			}
			return
		}
		if err := encodeResponse(ctx, w, res); err != nil {
			errhandler(ctx, w, err)
		}
	})
}
