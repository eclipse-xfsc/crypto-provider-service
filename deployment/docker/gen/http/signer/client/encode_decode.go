// Code generated by goa v3.12.3, DO NOT EDIT.
//
// signer HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/eclipse-xfsc/crypto-provider-service/design

package client

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"

	signer "github.com/eclipse-xfsc/crypto-provider-service/deployment/docker/gen/signer"
	goahttp "goa.design/goa/v3/http"
	goa "goa.design/goa/v3/pkg"
)

// BuildNamespacesRequest instantiates a HTTP request object with method and
// path set to call the "signer" service "Namespaces" endpoint
func (c *Client) BuildNamespacesRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: NamespacesSignerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "Namespaces", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeNamespacesResponse returns a decoder for responses returned by the
// signer Namespaces endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeNamespacesResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "Namespaces", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "Namespaces", resp.StatusCode, string(body))
		}
	}
}

// BuildNamespaceKeysRequest instantiates a HTTP request object with method and
// path set to call the "signer" service "NamespaceKeys" endpoint
func (c *Client) BuildNamespaceKeysRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		namespace string
	)
	{
		p, ok := v.(*signer.NamespaceKeysRequest)
		if !ok {
			return nil, goahttp.ErrInvalidType("signer", "NamespaceKeys", "*signer.NamespaceKeysRequest", v)
		}
		namespace = p.Namespace
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: NamespaceKeysSignerPath(namespace)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "NamespaceKeys", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeNamespaceKeysRequest returns an encoder for requests sent to the
// signer NamespaceKeys server.
func EncodeNamespaceKeysRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.NamespaceKeysRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "NamespaceKeys", "*signer.NamespaceKeysRequest", v)
		}
		{
			head := p.XGroup
			req.Header.Set("x-group", head)
		}
		return nil
	}
}

// DecodeNamespaceKeysResponse returns a decoder for responses returned by the
// signer NamespaceKeys endpoint. restoreBody controls whether the response
// body should be restored after having been read.
func DecodeNamespaceKeysResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body []string
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "NamespaceKeys", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "NamespaceKeys", resp.StatusCode, string(body))
		}
	}
}

// BuildVerificationMethodRequest instantiates a HTTP request object with
// method and path set to call the "signer" service "VerificationMethod"
// endpoint
func (c *Client) BuildVerificationMethodRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		namespace string
		key       string
		did       string
	)
	{
		p, ok := v.(*signer.VerificationMethodRequest)
		if !ok {
			return nil, goahttp.ErrInvalidType("signer", "VerificationMethod", "*signer.VerificationMethodRequest", v)
		}
		namespace = p.Namespace
		key = p.Key
		did = p.Did
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerificationMethodSignerPath(namespace, key, did)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "VerificationMethod", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerificationMethodRequest returns an encoder for requests sent to the
// signer VerificationMethod server.
func EncodeVerificationMethodRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.VerificationMethodRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "VerificationMethod", "*signer.VerificationMethodRequest", v)
		}
		body := NewVerificationMethodRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "VerificationMethod", err)
		}
		return nil
	}
}

// DecodeVerificationMethodResponse returns a decoder for responses returned by
// the signer VerificationMethod endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeVerificationMethodResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerificationMethodResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "VerificationMethod", err)
			}
			err = ValidateVerificationMethodResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "VerificationMethod", err)
			}
			res := NewVerificationMethodDIDVerificationMethodOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "VerificationMethod", resp.StatusCode, string(body))
		}
	}
}

// BuildVerificationMethodsRequest instantiates a HTTP request object with
// method and path set to call the "signer" service "VerificationMethods"
// endpoint
func (c *Client) BuildVerificationMethodsRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		namespace string
		did       string
	)
	{
		p, ok := v.(*signer.VerificationMethodsRequest)
		if !ok {
			return nil, goahttp.ErrInvalidType("signer", "VerificationMethods", "*signer.VerificationMethodsRequest", v)
		}
		namespace = p.Namespace
		did = p.Did
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerificationMethodsSignerPath(namespace, did)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "VerificationMethods", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerificationMethodsRequest returns an encoder for requests sent to the
// signer VerificationMethods server.
func EncodeVerificationMethodsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.VerificationMethodsRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "VerificationMethods", "*signer.VerificationMethodsRequest", v)
		}
		body := NewVerificationMethodsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "VerificationMethods", err)
		}
		return nil
	}
}

// DecodeVerificationMethodsResponse returns a decoder for responses returned
// by the signer VerificationMethods endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeVerificationMethodsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerificationMethodsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "VerificationMethods", err)
			}
			for _, e := range body {
				if e != nil {
					if err2 := ValidateDIDVerificationMethodResponse(e); err2 != nil {
						err = goa.MergeErrors(err, err2)
					}
				}
			}
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "VerificationMethods", err)
			}
			res := NewVerificationMethodsDIDVerificationMethodOK(body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "VerificationMethods", resp.StatusCode, string(body))
		}
	}
}

// BuildJwkPublicKeyRequest instantiates a HTTP request object with method and
// path set to call the "signer" service "JwkPublicKey" endpoint
func (c *Client) BuildJwkPublicKeyRequest(ctx context.Context, v any) (*http.Request, error) {
	var (
		namespace string
		key       string
	)
	{
		p, ok := v.(*signer.JwkPublicKeyRequest)
		if !ok {
			return nil, goahttp.ErrInvalidType("signer", "JwkPublicKey", "*signer.JwkPublicKeyRequest", v)
		}
		namespace = p.Namespace
		key = p.Key
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: JwkPublicKeySignerPath(namespace, key)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "JwkPublicKey", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeJwkPublicKeyRequest returns an encoder for requests sent to the signer
// JwkPublicKey server.
func EncodeJwkPublicKeyRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.JwkPublicKeyRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "JwkPublicKey", "*signer.JwkPublicKeyRequest", v)
		}
		body := NewJwkPublicKeyRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "JwkPublicKey", err)
		}
		return nil
	}
}

// DecodeJwkPublicKeyResponse returns a decoder for responses returned by the
// signer JwkPublicKey endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeJwkPublicKeyResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "JwkPublicKey", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "JwkPublicKey", resp.StatusCode, string(body))
		}
	}
}

// BuildCredentialProofRequest instantiates a HTTP request object with method
// and path set to call the "signer" service "CredentialProof" endpoint
func (c *Client) BuildCredentialProofRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CredentialProofSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "CredentialProof", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCredentialProofRequest returns an encoder for requests sent to the
// signer CredentialProof server.
func EncodeCredentialProofRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.CredentialProofRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "CredentialProof", "*signer.CredentialProofRequest", v)
		}
		body := NewCredentialProofRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "CredentialProof", err)
		}
		return nil
	}
}

// DecodeCredentialProofResponse returns a decoder for responses returned by
// the signer CredentialProof endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeCredentialProofResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "CredentialProof", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "CredentialProof", resp.StatusCode, string(body))
		}
	}
}

// BuildPresentationProofRequest instantiates a HTTP request object with method
// and path set to call the "signer" service "PresentationProof" endpoint
func (c *Client) BuildPresentationProofRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PresentationProofSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "PresentationProof", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePresentationProofRequest returns an encoder for requests sent to the
// signer PresentationProof server.
func EncodePresentationProofRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.PresentationProofRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "PresentationProof", "*signer.PresentationProofRequest", v)
		}
		body := NewPresentationProofRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "PresentationProof", err)
		}
		return nil
	}
}

// DecodePresentationProofResponse returns a decoder for responses returned by
// the signer PresentationProof endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodePresentationProofResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "PresentationProof", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "PresentationProof", resp.StatusCode, string(body))
		}
	}
}

// BuildCreateCredentialRequest instantiates a HTTP request object with method
// and path set to call the "signer" service "CreateCredential" endpoint
func (c *Client) BuildCreateCredentialRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreateCredentialSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "CreateCredential", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreateCredentialRequest returns an encoder for requests sent to the
// signer CreateCredential server.
func EncodeCreateCredentialRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.CreateCredentialRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "CreateCredential", "*signer.CreateCredentialRequest", v)
		}
		{
			head := p.XOrigin
			req.Header.Set("x-origin", head)
		}
		body := NewCreateCredentialRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "CreateCredential", err)
		}
		return nil
	}
}

// DecodeCreateCredentialResponse returns a decoder for responses returned by
// the signer CreateCredential endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeCreateCredentialResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "CreateCredential", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "CreateCredential", resp.StatusCode, string(body))
		}
	}
}

// BuildCreatePresentationRequest instantiates a HTTP request object with
// method and path set to call the "signer" service "CreatePresentation"
// endpoint
func (c *Client) BuildCreatePresentationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: CreatePresentationSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "CreatePresentation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeCreatePresentationRequest returns an encoder for requests sent to the
// signer CreatePresentation server.
func EncodeCreatePresentationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.CreatePresentationRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "CreatePresentation", "*signer.CreatePresentationRequest", v)
		}
		body := NewCreatePresentationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "CreatePresentation", err)
		}
		return nil
	}
}

// DecodeCreatePresentationResponse returns a decoder for responses returned by
// the signer CreatePresentation endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeCreatePresentationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "CreatePresentation", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "CreatePresentation", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyCredentialRequest instantiates a HTTP request object with method
// and path set to call the "signer" service "VerifyCredential" endpoint
func (c *Client) BuildVerifyCredentialRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyCredentialSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "VerifyCredential", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyCredentialRequest returns an encoder for requests sent to the
// signer VerifyCredential server.
func EncodeVerifyCredentialRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.VerifyCredentialRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "VerifyCredential", "*signer.VerifyCredentialRequest", v)
		}
		{
			head := p.XFormat
			req.Header.Set("x-format", head)
		}
		if p.XNamespace != nil {
			head := *p.XNamespace
			req.Header.Set("x-namespace", head)
		}
		if p.XGroup != nil {
			head := *p.XGroup
			req.Header.Set("x-group", head)
		}
		body := NewVerifyCredentialRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "VerifyCredential", err)
		}
		return nil
	}
}

// DecodeVerifyCredentialResponse returns a decoder for responses returned by
// the signer VerifyCredential endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeVerifyCredentialResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyCredentialResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "VerifyCredential", err)
			}
			err = ValidateVerifyCredentialResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "VerifyCredential", err)
			}
			res := NewVerifyCredentialVerifyResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "VerifyCredential", resp.StatusCode, string(body))
		}
	}
}

// BuildVerifyPresentationRequest instantiates a HTTP request object with
// method and path set to call the "signer" service "VerifyPresentation"
// endpoint
func (c *Client) BuildVerifyPresentationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VerifyPresentationSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "VerifyPresentation", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeVerifyPresentationRequest returns an encoder for requests sent to the
// signer VerifyPresentation server.
func EncodeVerifyPresentationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.VerifyPresentationRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "VerifyPresentation", "*signer.VerifyPresentationRequest", v)
		}
		{
			head := p.XFormat
			req.Header.Set("x-format", head)
		}
		body := NewVerifyPresentationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "VerifyPresentation", err)
		}
		return nil
	}
}

// DecodeVerifyPresentationResponse returns a decoder for responses returned by
// the signer VerifyPresentation endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeVerifyPresentationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VerifyPresentationResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "VerifyPresentation", err)
			}
			err = ValidateVerifyPresentationResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "VerifyPresentation", err)
			}
			res := NewVerifyPresentationVerifyResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "VerifyPresentation", resp.StatusCode, string(body))
		}
	}
}

// BuildSignRequest instantiates a HTTP request object with method and path set
// to call the "signer" service "Sign" endpoint
func (c *Client) BuildSignRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: SignSignerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "Sign", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeSignRequest returns an encoder for requests sent to the signer Sign
// server.
func EncodeSignRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.SignRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "Sign", "*signer.SignRequest", v)
		}
		body := NewSignRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "Sign", err)
		}
		return nil
	}
}

// DecodeSignResponse returns a decoder for responses returned by the signer
// Sign endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeSignResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body SignOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "Sign", err)
			}
			err = ValidateSignOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "Sign", err)
			}
			res := NewSignResultOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "Sign", resp.StatusCode, string(body))
		}
	}
}

// BuildDidDocRequest instantiates a HTTP request object with method and path
// set to call the "signer" service "didDoc" endpoint
func (c *Client) BuildDidDocRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DidDocSignerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "didDoc", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDidDocRequest returns an encoder for requests sent to the signer
// didDoc server.
func EncodeDidDocRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.DidRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "didDoc", "*signer.DidRequest", v)
		}
		{
			head := p.XNamespace
			req.Header.Set("x-namespace", head)
		}
		{
			head := p.XGroup
			req.Header.Set("x-group", head)
		}
		{
			head := p.XDid
			req.Header.Set("x-did", head)
		}
		{
			head := p.XEngine
			req.Header.Set("x-engine", head)
		}
		return nil
	}
}

// DecodeDidDocResponse returns a decoder for responses returned by the signer
// didDoc endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeDidDocResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DidDocOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "didDoc", err)
			}
			err = ValidateDidDocOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "didDoc", err)
			}
			res := NewDidDocDidResponseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "didDoc", resp.StatusCode, string(body))
		}
	}
}

// BuildDidListRequest instantiates a HTTP request object with method and path
// set to call the "signer" service "didList" endpoint
func (c *Client) BuildDidListRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DidListSignerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "didList", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDidListRequest returns an encoder for requests sent to the signer
// didList server.
func EncodeDidListRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.DidListRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "didList", "*signer.DidListRequest", v)
		}
		{
			head := p.XNamespace
			req.Header.Set("x-namespace", head)
		}
		{
			head := p.XGroup
			req.Header.Set("x-group", head)
		}
		{
			head := p.XEngine
			req.Header.Set("x-engine", head)
		}
		return nil
	}
}

// DecodeDidListResponse returns a decoder for responses returned by the signer
// didList endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeDidListResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body DidListOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "didList", err)
			}
			err = ValidateDidListOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "didList", err)
			}
			res := NewDidListResponseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "didList", resp.StatusCode, string(body))
		}
	}
}

// BuildDidConfigurationRequest instantiates a HTTP request object with method
// and path set to call the "signer" service "DidConfiguration" endpoint
func (c *Client) BuildDidConfigurationRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: DidConfigurationSignerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "DidConfiguration", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeDidConfigurationRequest returns an encoder for requests sent to the
// signer DidConfiguration server.
func EncodeDidConfigurationRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.DidConfiguration2)
		if !ok {
			return goahttp.ErrInvalidType("signer", "DidConfiguration", "*signer.DidConfiguration2", v)
		}
		{
			head := p.XNamespace
			req.Header.Set("x-namespace", head)
		}
		{
			head := p.XGroup
			req.Header.Set("x-group", head)
		}
		{
			head := p.XOrigin
			req.Header.Set("x-origin", head)
		}
		if p.XDid != nil {
			head := *p.XDid
			req.Header.Set("x-did", head)
		}
		if p.XNonce != nil {
			head := *p.XNonce
			req.Header.Set("x-nonce", head)
		}
		body := NewDidConfigurationRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("signer", "DidConfiguration", err)
		}
		return nil
	}
}

// DecodeDidConfigurationResponse returns a decoder for responses returned by
// the signer DidConfiguration endpoint. restoreBody controls whether the
// response body should be restored after having been read.
func DecodeDidConfigurationResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body any
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "DidConfiguration", err)
			}
			return body, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "DidConfiguration", resp.StatusCode, string(body))
		}
	}
}

// BuildJwksRequest instantiates a HTTP request object with method and path set
// to call the "signer" service "Jwks" endpoint
func (c *Client) BuildJwksRequest(ctx context.Context, v any) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: JwksSignerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("signer", "Jwks", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeJwksRequest returns an encoder for requests sent to the signer Jwks
// server.
func EncodeJwksRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, any) error {
	return func(req *http.Request, v any) error {
		p, ok := v.(*signer.JwksRequest)
		if !ok {
			return goahttp.ErrInvalidType("signer", "Jwks", "*signer.JwksRequest", v)
		}
		{
			head := p.XNamespace
			req.Header.Set("x-namespace", head)
		}
		if p.XGroup != nil {
			head := *p.XGroup
			req.Header.Set("x-group", head)
		}
		{
			head := p.XEngine
			req.Header.Set("x-engine", head)
		}
		return nil
	}
}

// DecodeJwksResponse returns a decoder for responses returned by the signer
// Jwks endpoint. restoreBody controls whether the response body should be
// restored after having been read.
func DecodeJwksResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (any, error) {
	return func(resp *http.Response) (any, error) {
		if restoreBody {
			b, err := io.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = io.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = io.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body JwksOKResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("signer", "Jwks", err)
			}
			err = ValidateJwksOKResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("signer", "Jwks", err)
			}
			res := NewJwksResponseOK(&body)
			return res, nil
		default:
			body, _ := io.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("signer", "Jwks", resp.StatusCode, string(body))
		}
	}
}

// unmarshalDIDVerificationMethodResponseToSignerDIDVerificationMethod builds a
// value of type *signer.DIDVerificationMethod from a value of type
// *DIDVerificationMethodResponse.
func unmarshalDIDVerificationMethodResponseToSignerDIDVerificationMethod(v *DIDVerificationMethodResponse) *signer.DIDVerificationMethod {
	res := &signer.DIDVerificationMethod{
		ID:           *v.ID,
		Type:         *v.Type,
		Controller:   *v.Controller,
		PublicKeyJwk: v.PublicKeyJwk,
	}

	return res
}

// unmarshalDIDVerificationMethodResponseBodyToSignerDIDVerificationMethod
// builds a value of type *signer.DIDVerificationMethod from a value of type
// *DIDVerificationMethodResponseBody.
func unmarshalDIDVerificationMethodResponseBodyToSignerDIDVerificationMethod(v *DIDVerificationMethodResponseBody) *signer.DIDVerificationMethod {
	if v == nil {
		return nil
	}
	res := &signer.DIDVerificationMethod{
		ID:           *v.ID,
		Type:         *v.Type,
		Controller:   *v.Controller,
		PublicKeyJwk: v.PublicKeyJwk,
	}

	return res
}

// unmarshalServiceEndpointResponseBodyToSignerServiceEndpoint builds a value
// of type *signer.ServiceEndpoint from a value of type
// *ServiceEndpointResponseBody.
func unmarshalServiceEndpointResponseBodyToSignerServiceEndpoint(v *ServiceEndpointResponseBody) *signer.ServiceEndpoint {
	if v == nil {
		return nil
	}
	res := &signer.ServiceEndpoint{
		ID:              *v.ID,
		Type:            *v.Type,
		ServiceEndpoint: *v.ServiceEndpoint,
	}

	return res
}

// unmarshalDidListResponseItemResponseBodyToSignerDidListResponseItem builds a
// value of type *signer.DidListResponseItem from a value of type
// *DidListResponseItemResponseBody.
func unmarshalDidListResponseItemResponseBodyToSignerDidListResponseItem(v *DidListResponseItemResponseBody) *signer.DidListResponseItem {
	res := &signer.DidListResponseItem{
		Name: *v.Name,
		Did:  *v.Did,
	}

	return res
}
