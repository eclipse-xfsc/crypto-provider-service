// Code generated by goa v3.12.3, DO NOT EDIT.
//
// signer HTTP client types
//
// Command:
// $ goa gen github.com/eclipse-xfsc/crypto-provider-service/design

package client

import (
	signer "github.com/eclipse-xfsc/crypto-provider-service/deployment/docker/gen/signer"
	goa "goa.design/goa/v3/pkg"
)

// VerificationMethodRequestBody is the type of the "signer" service
// "VerificationMethod" endpoint HTTP request body.
type VerificationMethodRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine string `form:"engine" json:"engine" xml:"engine"`
}

// VerificationMethodsRequestBody is the type of the "signer" service
// "VerificationMethods" endpoint HTTP request body.
type VerificationMethodsRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine string `form:"engine" json:"engine" xml:"engine"`
}

// JwkPublicKeyRequestBody is the type of the "signer" service "JwkPublicKey"
// endpoint HTTP request body.
type JwkPublicKeyRequestBody struct {
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// Engine which shall be used. Eg transit or transit;kv or kv
	Engine string `form:"engine" json:"engine" xml:"engine"`
}

// CredentialProofRequestBody is the type of the "signer" service
// "CredentialProof" endpoint HTTP request body.
type CredentialProofRequestBody struct {
	// Key namespace.
	Namespace string `form:"namespace" json:"namespace" xml:"namespace"`
	// Key to use for the proof signature (optional).
	Key string `form:"key" json:"key" xml:"key"`
	// Verifiable Credential in JSON format or as sdjwt.
	Credential any `form:"credential" json:"credential" xml:"credential"`
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// identifies the format of the credential.
	Format string `form:"format" json:"format" xml:"format"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature.For sd-jwt is it automatically selected.
	SignatureType string `form:"signatureType" json:"signatureType" xml:"signatureType"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
}

// PresentationProofRequestBody is the type of the "signer" service
// "PresentationProof" endpoint HTTP request body.
type PresentationProofRequestBody struct {
	// Issuer DID used to specify proof verification info.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace string `form:"namespace" json:"namespace" xml:"namespace"`
	// Key to use for the proof signature.
	Key string `form:"key" json:"key" xml:"key"`
	// Verifiable Presentation in JSON format.
	Presentation any `form:"presentation" json:"presentation" xml:"presentation"`
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature.For sd-jwt is it automatically selected.
	SignatureType string `form:"signatureType" json:"signatureType" xml:"signatureType"`
	// identifies the format of the credential.
	Format string `form:"format" json:"format" xml:"format"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// audience
	Aud *string `form:"aud,omitempty" json:"aud,omitempty" xml:"aud,omitempty"`
}

// CreateCredentialRequestBody is the type of the "signer" service
// "CreateCredential" endpoint HTTP request body.
type CreateCredentialRequestBody struct {
	// Issuer DID of the Verifiable Credential.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace string `form:"namespace" json:"namespace" xml:"namespace"`
	// Key to use for the proof signature.
	Key string `form:"key" json:"key" xml:"key"`
	// Raw JSON that will be the VC subject.
	CredentialSubject any `form:"credentialSubject" json:"credentialSubject" xml:"credentialSubject"`
	// Additional JSONLD contexts to be specified in the VC.
	Context []string `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// identifies the format of the credential.
	Format string `form:"format" json:"format" xml:"format"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Append Status
	Status *bool `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Type of signature. For sd-jwt is it automatically selected.
	SignatureType string `form:"signatureType" json:"signatureType" xml:"signatureType"`
	// Type(s) of the credential. Just first one for sd-jwt used.
	Type []string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// Holder Binding
	Holder *string `form:"holder,omitempty" json:"holder,omitempty" xml:"holder,omitempty"`
}

// CreatePresentationRequestBody is the type of the "signer" service
// "CreatePresentation" endpoint HTTP request body.
type CreatePresentationRequestBody struct {
	// Issuer DID of the Verifiable Presentation.
	Issuer *string `form:"issuer,omitempty" json:"issuer,omitempty" xml:"issuer,omitempty"`
	// Key namespace.
	Namespace string `form:"namespace" json:"namespace" xml:"namespace"`
	// Key to use for the proof signature.
	Key string `form:"key" json:"key" xml:"key"`
	// Raw JSON to be included inside the VP as Verifiable Credential.
	Data []any `form:"data" json:"data" xml:"data"`
	// Additional JSONLD contexts to be specified in the VP.
	Context []string `form:"context,omitempty" json:"context,omitempty" xml:"context,omitempty"`
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
	// Proof challenge
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
	// Type of signature. For sd-jwt is it automatically selected.
	SignatureType string `form:"signatureType" json:"signatureType" xml:"signatureType"`
}

// VerifyCredentialRequestBody is the type of the "signer" service
// "VerifyCredential" endpoint HTTP request body.
type VerifyCredentialRequestBody struct {
	// Verifiable Credential in JSON format.
	Credential []byte `form:"credential" json:"credential" xml:"credential"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
}

// VerifyPresentationRequestBody is the type of the "signer" service
// "VerifyPresentation" endpoint HTTP request body.
type VerifyPresentationRequestBody struct {
	// Verifiable Presentation in JSON or sdjwt format.
	Presentation []byte `form:"presentation" json:"presentation" xml:"presentation"`
	// Disclosed Attributes
	DisclosureFrame []string `form:"disclosureFrame,omitempty" json:"disclosureFrame,omitempty" xml:"disclosureFrame,omitempty"`
	// expected audience
	Aud *string `form:"aud,omitempty" json:"aud,omitempty" xml:"aud,omitempty"`
	// expected nonce
	Nonce *string `form:"nonce,omitempty" json:"nonce,omitempty" xml:"nonce,omitempty"`
}

// SignRequestBody is the type of the "signer" service "Sign" endpoint HTTP
// request body.
type SignRequestBody struct {
	// Key namespace to be used for signing.
	Namespace string `form:"namespace" json:"namespace" xml:"namespace"`
	// Key to be used for signing.
	Key string `form:"key" json:"key" xml:"key"`
	// Data that must be signed, encoded as base64 string.
	Data string `form:"data" json:"data" xml:"data"`
	// Group identifies a group of keys within a namespace.
	Group string `form:"group" json:"group" xml:"group"`
}

// DidConfigurationRequestBody is the type of the "signer" service
// "DidConfiguration" endpoint HTTP request body.
type DidConfigurationRequestBody struct {
	// Type of signature
	XSignatureType string `form:"x-signatureType" json:"x-signatureType" xml:"x-signatureType"`
}

// VerificationMethodResponseBody is the type of the "signer" service
// "VerificationMethod" endpoint HTTP response body.
type VerificationMethodResponseBody struct {
	// ID of verification method.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of verification method key.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Controller of verification method specified as DID.
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk,omitempty" json:"publicKeyJwk,omitempty" xml:"publicKeyJwk,omitempty"`
}

// VerificationMethodsResponseBody is the type of the "signer" service
// "VerificationMethods" endpoint HTTP response body.
type VerificationMethodsResponseBody []*DIDVerificationMethodResponse

// VerifyCredentialResponseBody is the type of the "signer" service
// "VerifyCredential" endpoint HTTP response body.
type VerifyCredentialResponseBody struct {
	// Valid specifies if the proof is successfully verified.
	Valid *bool `form:"valid,omitempty" json:"valid,omitempty" xml:"valid,omitempty"`
	// Disclosed Credential
	DisclosedCredential any `form:"disclosedCredential,omitempty" json:"disclosedCredential,omitempty" xml:"disclosedCredential,omitempty"`
}

// VerifyPresentationResponseBody is the type of the "signer" service
// "VerifyPresentation" endpoint HTTP response body.
type VerifyPresentationResponseBody struct {
	// Valid specifies if the proof is successfully verified.
	Valid *bool `form:"valid,omitempty" json:"valid,omitempty" xml:"valid,omitempty"`
	// Disclosed Credential
	DisclosedCredential any `form:"disclosedCredential,omitempty" json:"disclosedCredential,omitempty" xml:"disclosedCredential,omitempty"`
}

// SignOKResponseBody is the type of the "signer" service "Sign" endpoint HTTP
// response body.
type SignOKResponseBody struct {
	// Signature encoded as base64 string.
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// DidDocOKResponseBody is the type of the "signer" service "didDoc" endpoint
// HTTP response body.
type DidDocOKResponseBody struct {
	// did of the document
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// controler of the document
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// methods of the document
	VerificationMethod []*DIDVerificationMethodResponseBody `form:"verificationMethod,omitempty" json:"verificationMethod,omitempty" xml:"verificationMethod,omitempty"`
	// serviceendpoints
	Service []*ServiceEndpointResponseBody `form:"service,omitempty" json:"service,omitempty" xml:"service,omitempty"`
}

// DidListOKResponseBody is the type of the "signer" service "didList" endpoint
// HTTP response body.
type DidListOKResponseBody struct {
	// did jwk list of keys
	List []*DidListResponseItemResponseBody `form:"list,omitempty" json:"list,omitempty" xml:"list,omitempty"`
}

// JwksOKResponseBody is the type of the "signer" service "Jwks" endpoint HTTP
// response body.
type JwksOKResponseBody struct {
	// List of jwk
	Keys []any `form:"keys,omitempty" json:"keys,omitempty" xml:"keys,omitempty"`
}

// DIDVerificationMethodResponse is used to define fields on response body
// types.
type DIDVerificationMethodResponse struct {
	// ID of verification method.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of verification method key.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Controller of verification method specified as DID.
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk,omitempty" json:"publicKeyJwk,omitempty" xml:"publicKeyJwk,omitempty"`
}

// SignNotFoundResponseBody is used to define fields on response body types.
type SignNotFoundResponseBody struct {
	// Signature encoded as base64 string.
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// SignInternalServerErrorResponseBody is used to define fields on response
// body types.
type SignInternalServerErrorResponseBody struct {
	// Signature encoded as base64 string.
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// DIDVerificationMethodResponseBody is used to define fields on response body
// types.
type DIDVerificationMethodResponseBody struct {
	// ID of verification method.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Type of verification method key.
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Controller of verification method specified as DID.
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// Public Key encoded in JWK format.
	PublicKeyJwk any `form:"publicKeyJwk,omitempty" json:"publicKeyJwk,omitempty" xml:"publicKeyJwk,omitempty"`
}

// ServiceEndpointResponseBody is used to define fields on response body types.
type ServiceEndpointResponseBody struct {
	// did of the document
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// type of endpoint
	Type *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Endpoint URL
	ServiceEndpoint *string `form:"serviceEndpoint,omitempty" json:"serviceEndpoint,omitempty" xml:"serviceEndpoint,omitempty"`
}

// DidDocNotFoundResponseBody is used to define fields on response body types.
type DidDocNotFoundResponseBody struct {
	// did of the document
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// controler of the document
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// methods of the document
	VerificationMethod []*DIDVerificationMethodResponseBody `form:"verificationMethod,omitempty" json:"verificationMethod,omitempty" xml:"verificationMethod,omitempty"`
	// serviceendpoints
	Service []*ServiceEndpointResponseBody `form:"service,omitempty" json:"service,omitempty" xml:"service,omitempty"`
}

// DidDocInternalServerErrorResponseBody is used to define fields on response
// body types.
type DidDocInternalServerErrorResponseBody struct {
	// did of the document
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// controler of the document
	Controller *string `form:"controller,omitempty" json:"controller,omitempty" xml:"controller,omitempty"`
	// methods of the document
	VerificationMethod []*DIDVerificationMethodResponseBody `form:"verificationMethod,omitempty" json:"verificationMethod,omitempty" xml:"verificationMethod,omitempty"`
	// serviceendpoints
	Service []*ServiceEndpointResponseBody `form:"service,omitempty" json:"service,omitempty" xml:"service,omitempty"`
}

// DidListResponseItemResponseBody is used to define fields on response body
// types.
type DidListResponseItemResponseBody struct {
	// name of the key.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// DID JWK of key
	Did *string `form:"did,omitempty" json:"did,omitempty" xml:"did,omitempty"`
}

// DidListNotFoundResponseBody is used to define fields on response body types.
type DidListNotFoundResponseBody struct {
	// did jwk list of keys
	List []*DidListResponseItemResponseBody `form:"list,omitempty" json:"list,omitempty" xml:"list,omitempty"`
}

// DidListInternalServerErrorResponseBody is used to define fields on response
// body types.
type DidListInternalServerErrorResponseBody struct {
	// did jwk list of keys
	List []*DidListResponseItemResponseBody `form:"list,omitempty" json:"list,omitempty" xml:"list,omitempty"`
}

// JwksNotFoundResponseBody is used to define fields on response body types.
type JwksNotFoundResponseBody struct {
	// List of jwk
	Keys []any `form:"keys,omitempty" json:"keys,omitempty" xml:"keys,omitempty"`
}

// JwksInternalServerErrorResponseBody is used to define fields on response
// body types.
type JwksInternalServerErrorResponseBody struct {
	// List of jwk
	Keys []any `form:"keys,omitempty" json:"keys,omitempty" xml:"keys,omitempty"`
}

// NewVerificationMethodRequestBody builds the HTTP request body from the
// payload of the "VerificationMethod" endpoint of the "signer" service.
func NewVerificationMethodRequestBody(p *signer.VerificationMethodRequest) *VerificationMethodRequestBody {
	body := &VerificationMethodRequestBody{
		Group:  p.Group,
		Engine: p.Engine,
	}
	{
		var zero string
		if body.Group == zero {
			body.Group = ""
		}
	}
	{
		var zero string
		if body.Engine == zero {
			body.Engine = "transit"
		}
	}
	return body
}

// NewVerificationMethodsRequestBody builds the HTTP request body from the
// payload of the "VerificationMethods" endpoint of the "signer" service.
func NewVerificationMethodsRequestBody(p *signer.VerificationMethodsRequest) *VerificationMethodsRequestBody {
	body := &VerificationMethodsRequestBody{
		Group:  p.Group,
		Engine: p.Engine,
	}
	{
		var zero string
		if body.Group == zero {
			body.Group = ""
		}
	}
	{
		var zero string
		if body.Engine == zero {
			body.Engine = "transit"
		}
	}
	return body
}

// NewJwkPublicKeyRequestBody builds the HTTP request body from the payload of
// the "JwkPublicKey" endpoint of the "signer" service.
func NewJwkPublicKeyRequestBody(p *signer.JwkPublicKeyRequest) *JwkPublicKeyRequestBody {
	body := &JwkPublicKeyRequestBody{
		Group:  p.Group,
		Engine: p.Engine,
	}
	{
		var zero string
		if body.Engine == zero {
			body.Engine = "transit"
		}
	}
	return body
}

// NewCredentialProofRequestBody builds the HTTP request body from the payload
// of the "CredentialProof" endpoint of the "signer" service.
func NewCredentialProofRequestBody(p *signer.CredentialProofRequest) *CredentialProofRequestBody {
	body := &CredentialProofRequestBody{
		Namespace:     p.Namespace,
		Key:           p.Key,
		Credential:    p.Credential,
		Group:         p.Group,
		Format:        p.Format,
		Nonce:         p.Nonce,
		SignatureType: p.SignatureType,
	}
	{
		var zero string
		if body.Format == zero {
			body.Format = "ldp_vc"
		}
	}
	{
		var zero string
		if body.SignatureType == zero {
			body.SignatureType = "jsonwebsignature2020"
		}
	}
	if p.DisclosureFrame != nil {
		body.DisclosureFrame = make([]string, len(p.DisclosureFrame))
		for i, val := range p.DisclosureFrame {
			body.DisclosureFrame[i] = val
		}
	}
	return body
}

// NewPresentationProofRequestBody builds the HTTP request body from the
// payload of the "PresentationProof" endpoint of the "signer" service.
func NewPresentationProofRequestBody(p *signer.PresentationProofRequest) *PresentationProofRequestBody {
	body := &PresentationProofRequestBody{
		Issuer:        p.Issuer,
		Namespace:     p.Namespace,
		Key:           p.Key,
		Presentation:  p.Presentation,
		Group:         p.Group,
		Nonce:         p.Nonce,
		SignatureType: p.SignatureType,
		Format:        p.Format,
		Aud:           p.Aud,
	}
	{
		var zero string
		if body.SignatureType == zero {
			body.SignatureType = "jsonwebsignature2020"
		}
	}
	{
		var zero string
		if body.Format == zero {
			body.Format = "ldp_vc"
		}
	}
	if p.DisclosureFrame != nil {
		body.DisclosureFrame = make([]string, len(p.DisclosureFrame))
		for i, val := range p.DisclosureFrame {
			body.DisclosureFrame[i] = val
		}
	}
	return body
}

// NewCreateCredentialRequestBody builds the HTTP request body from the payload
// of the "CreateCredential" endpoint of the "signer" service.
func NewCreateCredentialRequestBody(p *signer.CreateCredentialRequest) *CreateCredentialRequestBody {
	body := &CreateCredentialRequestBody{
		Issuer:            p.Issuer,
		Namespace:         p.Namespace,
		Key:               p.Key,
		CredentialSubject: p.CredentialSubject,
		Group:             p.Group,
		Format:            p.Format,
		Nonce:             p.Nonce,
		Status:            p.Status,
		SignatureType:     p.SignatureType,
		Holder:            p.Holder,
	}
	if p.Context != nil {
		body.Context = make([]string, len(p.Context))
		for i, val := range p.Context {
			body.Context[i] = val
		}
	}
	{
		var zero string
		if body.Format == zero {
			body.Format = "ldp_vc"
		}
	}
	{
		var zero string
		if body.SignatureType == zero {
			body.SignatureType = "jsonwebsignature2020"
		}
	}
	if p.Type != nil {
		body.Type = make([]string, len(p.Type))
		for i, val := range p.Type {
			body.Type[i] = val
		}
	}
	if p.DisclosureFrame != nil {
		body.DisclosureFrame = make([]string, len(p.DisclosureFrame))
		for i, val := range p.DisclosureFrame {
			body.DisclosureFrame[i] = val
		}
	}
	return body
}

// NewCreatePresentationRequestBody builds the HTTP request body from the
// payload of the "CreatePresentation" endpoint of the "signer" service.
func NewCreatePresentationRequestBody(p *signer.CreatePresentationRequest) *CreatePresentationRequestBody {
	body := &CreatePresentationRequestBody{
		Issuer:        p.Issuer,
		Namespace:     p.Namespace,
		Key:           p.Key,
		Group:         p.Group,
		Nonce:         p.Nonce,
		SignatureType: p.SignatureType,
	}
	if p.Data != nil {
		body.Data = make([]any, len(p.Data))
		for i, val := range p.Data {
			body.Data[i] = val
		}
	} else {
		body.Data = []any{}
	}
	if p.Context != nil {
		body.Context = make([]string, len(p.Context))
		for i, val := range p.Context {
			body.Context[i] = val
		}
	}
	{
		var zero string
		if body.SignatureType == zero {
			body.SignatureType = "jsonwebsignature2020"
		}
	}
	return body
}

// NewVerifyCredentialRequestBody builds the HTTP request body from the payload
// of the "VerifyCredential" endpoint of the "signer" service.
func NewVerifyCredentialRequestBody(p *signer.VerifyCredentialRequest) *VerifyCredentialRequestBody {
	body := &VerifyCredentialRequestBody{
		Credential: p.Credential,
	}
	if p.DisclosureFrame != nil {
		body.DisclosureFrame = make([]string, len(p.DisclosureFrame))
		for i, val := range p.DisclosureFrame {
			body.DisclosureFrame[i] = val
		}
	}
	return body
}

// NewVerifyPresentationRequestBody builds the HTTP request body from the
// payload of the "VerifyPresentation" endpoint of the "signer" service.
func NewVerifyPresentationRequestBody(p *signer.VerifyPresentationRequest) *VerifyPresentationRequestBody {
	body := &VerifyPresentationRequestBody{
		Presentation: p.Presentation,
		Aud:          p.Aud,
		Nonce:        p.Nonce,
	}
	if p.DisclosureFrame != nil {
		body.DisclosureFrame = make([]string, len(p.DisclosureFrame))
		for i, val := range p.DisclosureFrame {
			body.DisclosureFrame[i] = val
		}
	}
	return body
}

// NewSignRequestBody builds the HTTP request body from the payload of the
// "Sign" endpoint of the "signer" service.
func NewSignRequestBody(p *signer.SignRequest) *SignRequestBody {
	body := &SignRequestBody{
		Namespace: p.Namespace,
		Key:       p.Key,
		Data:      p.Data,
		Group:     p.Group,
	}
	return body
}

// NewDidConfigurationRequestBody builds the HTTP request body from the payload
// of the "DidConfiguration" endpoint of the "signer" service.
func NewDidConfigurationRequestBody(p *signer.DidConfiguration2) *DidConfigurationRequestBody {
	body := &DidConfigurationRequestBody{
		XSignatureType: p.XSignatureType,
	}
	{
		var zero string
		if body.XSignatureType == zero {
			body.XSignatureType = "jsonwebsignature2020"
		}
	}
	return body
}

// NewVerificationMethodDIDVerificationMethodOK builds a "signer" service
// "VerificationMethod" endpoint result from a HTTP "OK" response.
func NewVerificationMethodDIDVerificationMethodOK(body *VerificationMethodResponseBody) *signer.DIDVerificationMethod {
	v := &signer.DIDVerificationMethod{
		ID:           *body.ID,
		Type:         *body.Type,
		Controller:   *body.Controller,
		PublicKeyJwk: body.PublicKeyJwk,
	}

	return v
}

// NewVerificationMethodsDIDVerificationMethodOK builds a "signer" service
// "VerificationMethods" endpoint result from a HTTP "OK" response.
func NewVerificationMethodsDIDVerificationMethodOK(body []*DIDVerificationMethodResponse) []*signer.DIDVerificationMethod {
	v := make([]*signer.DIDVerificationMethod, len(body))
	for i, val := range body {
		v[i] = unmarshalDIDVerificationMethodResponseToSignerDIDVerificationMethod(val)
	}

	return v
}

// NewVerifyCredentialVerifyResultOK builds a "signer" service
// "VerifyCredential" endpoint result from a HTTP "OK" response.
func NewVerifyCredentialVerifyResultOK(body *VerifyCredentialResponseBody) *signer.VerifyResult {
	v := &signer.VerifyResult{
		Valid:               *body.Valid,
		DisclosedCredential: body.DisclosedCredential,
	}

	return v
}

// NewVerifyPresentationVerifyResultOK builds a "signer" service
// "VerifyPresentation" endpoint result from a HTTP "OK" response.
func NewVerifyPresentationVerifyResultOK(body *VerifyPresentationResponseBody) *signer.VerifyResult {
	v := &signer.VerifyResult{
		Valid:               *body.Valid,
		DisclosedCredential: body.DisclosedCredential,
	}

	return v
}

// NewSignResultOK builds a "signer" service "Sign" endpoint result from a HTTP
// "OK" response.
func NewSignResultOK(body *SignOKResponseBody) *signer.SignResult {
	v := &signer.SignResult{
		Signature: *body.Signature,
	}

	return v
}

// NewDidDocDidResponseOK builds a "signer" service "didDoc" endpoint result
// from a HTTP "OK" response.
func NewDidDocDidResponseOK(body *DidDocOKResponseBody) *signer.DidResponse {
	v := &signer.DidResponse{
		ID:         *body.ID,
		Controller: *body.Controller,
	}
	if body.VerificationMethod != nil {
		v.VerificationMethod = make([]*signer.DIDVerificationMethod, len(body.VerificationMethod))
		for i, val := range body.VerificationMethod {
			v.VerificationMethod[i] = unmarshalDIDVerificationMethodResponseBodyToSignerDIDVerificationMethod(val)
		}
	}
	if body.Service != nil {
		v.Service = make([]*signer.ServiceEndpoint, len(body.Service))
		for i, val := range body.Service {
			v.Service[i] = unmarshalServiceEndpointResponseBodyToSignerServiceEndpoint(val)
		}
	}

	return v
}

// NewDidListResponseOK builds a "signer" service "didList" endpoint result
// from a HTTP "OK" response.
func NewDidListResponseOK(body *DidListOKResponseBody) *signer.DidListResponse {
	v := &signer.DidListResponse{}
	v.List = make([]*signer.DidListResponseItem, len(body.List))
	for i, val := range body.List {
		v.List[i] = unmarshalDidListResponseItemResponseBodyToSignerDidListResponseItem(val)
	}

	return v
}

// NewJwksResponseOK builds a "signer" service "Jwks" endpoint result from a
// HTTP "OK" response.
func NewJwksResponseOK(body *JwksOKResponseBody) *signer.JwksResponse {
	v := &signer.JwksResponse{}
	v.Keys = make([]any, len(body.Keys))
	for i, val := range body.Keys {
		v.Keys[i] = val
	}

	return v
}

// ValidateVerificationMethodResponseBody runs the validations defined on
// VerificationMethodResponseBody
func ValidateVerificationMethodResponseBody(body *VerificationMethodResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	if body.PublicKeyJwk == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("publicKeyJwk", "body"))
	}
	return
}

// ValidateVerifyCredentialResponseBody runs the validations defined on
// VerifyCredentialResponseBody
func ValidateVerifyCredentialResponseBody(body *VerifyCredentialResponseBody) (err error) {
	if body.Valid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("valid", "body"))
	}
	return
}

// ValidateVerifyPresentationResponseBody runs the validations defined on
// VerifyPresentationResponseBody
func ValidateVerifyPresentationResponseBody(body *VerifyPresentationResponseBody) (err error) {
	if body.Valid == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("valid", "body"))
	}
	return
}

// ValidateSignOKResponseBody runs the validations defined on SignOKResponseBody
func ValidateSignOKResponseBody(body *SignOKResponseBody) (err error) {
	if body.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signature", "body"))
	}
	return
}

// ValidateDidDocOKResponseBody runs the validations defined on
// DidDocOKResponseBody
func ValidateDidDocOKResponseBody(body *DidDocOKResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	for _, e := range body.VerificationMethod {
		if e != nil {
			if err2 := ValidateDIDVerificationMethodResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Service {
		if e != nil {
			if err2 := ValidateServiceEndpointResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDidListOKResponseBody runs the validations defined on
// DidListOKResponseBody
func ValidateDidListOKResponseBody(body *DidListOKResponseBody) (err error) {
	if body.List == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("list", "body"))
	}
	for _, e := range body.List {
		if e != nil {
			if err2 := ValidateDidListResponseItemResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateJwksOKResponseBody runs the validations defined on JwksOKResponseBody
func ValidateJwksOKResponseBody(body *JwksOKResponseBody) (err error) {
	if body.Keys == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("keys", "body"))
	}
	return
}

// ValidateDIDVerificationMethodResponse runs the validations defined on
// DIDVerificationMethodResponse
func ValidateDIDVerificationMethodResponse(body *DIDVerificationMethodResponse) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	if body.PublicKeyJwk == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("publicKeyJwk", "body"))
	}
	return
}

// ValidateSignNotFoundResponseBody runs the validations defined on SignNot
// FoundResponseBody
func ValidateSignNotFoundResponseBody(body *SignNotFoundResponseBody) (err error) {
	if body.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signature", "body"))
	}
	return
}

// ValidateSignInternalServerErrorResponseBody runs the validations defined on
// SignInternal Server ErrorResponseBody
func ValidateSignInternalServerErrorResponseBody(body *SignInternalServerErrorResponseBody) (err error) {
	if body.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signature", "body"))
	}
	return
}

// ValidateDIDVerificationMethodResponseBody runs the validations defined on
// DIDVerificationMethodResponseBody
func ValidateDIDVerificationMethodResponseBody(body *DIDVerificationMethodResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	if body.PublicKeyJwk == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("publicKeyJwk", "body"))
	}
	return
}

// ValidateServiceEndpointResponseBody runs the validations defined on
// serviceEndpointResponseBody
func ValidateServiceEndpointResponseBody(body *ServiceEndpointResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.ServiceEndpoint == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("serviceEndpoint", "body"))
	}
	return
}

// ValidateDidDocNotFoundResponseBody runs the validations defined on DidDocNot
// FoundResponseBody
func ValidateDidDocNotFoundResponseBody(body *DidDocNotFoundResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	for _, e := range body.VerificationMethod {
		if e != nil {
			if err2 := ValidateDIDVerificationMethodResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Service {
		if e != nil {
			if err2 := ValidateServiceEndpointResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDidDocInternalServerErrorResponseBody runs the validations defined
// on DidDocInternal Server ErrorResponseBody
func ValidateDidDocInternalServerErrorResponseBody(body *DidDocInternalServerErrorResponseBody) (err error) {
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Controller == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("controller", "body"))
	}
	for _, e := range body.VerificationMethod {
		if e != nil {
			if err2 := ValidateDIDVerificationMethodResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.Service {
		if e != nil {
			if err2 := ValidateServiceEndpointResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDidListResponseItemResponseBody runs the validations defined on
// DidListResponseItemResponseBody
func ValidateDidListResponseItemResponseBody(body *DidListResponseItemResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.Did == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("did", "body"))
	}
	return
}

// ValidateDidListNotFoundResponseBody runs the validations defined on
// DidListNot FoundResponseBody
func ValidateDidListNotFoundResponseBody(body *DidListNotFoundResponseBody) (err error) {
	if body.List == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("list", "body"))
	}
	for _, e := range body.List {
		if e != nil {
			if err2 := ValidateDidListResponseItemResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateDidListInternalServerErrorResponseBody runs the validations defined
// on DidListInternal Server ErrorResponseBody
func ValidateDidListInternalServerErrorResponseBody(body *DidListInternalServerErrorResponseBody) (err error) {
	if body.List == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("list", "body"))
	}
	for _, e := range body.List {
		if e != nil {
			if err2 := ValidateDidListResponseItemResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateJwksNotFoundResponseBody runs the validations defined on JwksNot
// FoundResponseBody
func ValidateJwksNotFoundResponseBody(body *JwksNotFoundResponseBody) (err error) {
	if body.Keys == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("keys", "body"))
	}
	return
}

// ValidateJwksInternalServerErrorResponseBody runs the validations defined on
// JwksInternal Server ErrorResponseBody
func ValidateJwksInternalServerErrorResponseBody(body *JwksInternalServerErrorResponseBody) (err error) {
	if body.Keys == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("keys", "body"))
	}
	return
}
