// Code generated by goa v3.12.3, DO NOT EDIT.
//
// signer HTTP client CLI support package
//
// Command:
// $ goa gen github.com/eclipse-xfsc/crypto-provider-service/design

package client

import (
	"encoding/json"
	"fmt"

	signer "github.com/eclipse-xfsc/crypto-provider-service/gen/signer"
	goa "goa.design/goa/v3/pkg"
)

// BuildNamespaceKeysPayload builds the payload for the signer NamespaceKeys
// endpoint from CLI flags.
func BuildNamespaceKeysPayload(signerNamespaceKeysNamespace string, signerNamespaceKeysXGroup string) (*signer.NamespaceKeysRequest, error) {
	var namespace string
	{
		namespace = signerNamespaceKeysNamespace
	}
	var xGroup string
	{
		if signerNamespaceKeysXGroup != "" {
			xGroup = signerNamespaceKeysXGroup
		}
	}
	v := &signer.NamespaceKeysRequest{}
	v.Namespace = namespace
	v.XGroup = xGroup

	return v, nil
}

// BuildVerificationMethodPayload builds the payload for the signer
// VerificationMethod endpoint from CLI flags.
func BuildVerificationMethodPayload(signerVerificationMethodBody string, signerVerificationMethodNamespace string, signerVerificationMethodKey string, signerVerificationMethodDid string) (*signer.VerificationMethodRequest, error) {
	var err error
	var body VerificationMethodRequestBody
	{
		err = json.Unmarshal([]byte(signerVerificationMethodBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"engine\": \"transit\",\n      \"group\": \"Group\"\n   }'")
		}
	}
	var namespace string
	{
		namespace = signerVerificationMethodNamespace
	}
	var key string
	{
		key = signerVerificationMethodKey
	}
	var did string
	{
		did = signerVerificationMethodDid
	}
	v := &signer.VerificationMethodRequest{
		Group:  body.Group,
		Engine: body.Engine,
	}
	{
		var zero string
		if v.Group == zero {
			v.Group = ""
		}
	}
	{
		var zero string
		if v.Engine == zero {
			v.Engine = "transit"
		}
	}
	v.Namespace = namespace
	v.Key = key
	v.Did = did

	return v, nil
}

// BuildVerificationMethodsPayload builds the payload for the signer
// VerificationMethods endpoint from CLI flags.
func BuildVerificationMethodsPayload(signerVerificationMethodsBody string, signerVerificationMethodsNamespace string, signerVerificationMethodsDid string) (*signer.VerificationMethodsRequest, error) {
	var err error
	var body VerificationMethodsRequestBody
	{
		err = json.Unmarshal([]byte(signerVerificationMethodsBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"engine\": \"transit\",\n      \"group\": \"Group\"\n   }'")
		}
	}
	var namespace string
	{
		namespace = signerVerificationMethodsNamespace
	}
	var did string
	{
		did = signerVerificationMethodsDid
	}
	v := &signer.VerificationMethodsRequest{
		Group:  body.Group,
		Engine: body.Engine,
	}
	{
		var zero string
		if v.Group == zero {
			v.Group = ""
		}
	}
	{
		var zero string
		if v.Engine == zero {
			v.Engine = "transit"
		}
	}
	v.Namespace = namespace
	v.Did = did

	return v, nil
}

// BuildJwkPublicKeyPayload builds the payload for the signer JwkPublicKey
// endpoint from CLI flags.
func BuildJwkPublicKeyPayload(signerJwkPublicKeyBody string, signerJwkPublicKeyNamespace string, signerJwkPublicKeyKey string) (*signer.JwkPublicKeyRequest, error) {
	var err error
	var body JwkPublicKeyRequestBody
	{
		err = json.Unmarshal([]byte(signerJwkPublicKeyBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"engine\": \"transit\",\n      \"group\": \"Group\"\n   }'")
		}
	}
	var namespace string
	{
		namespace = signerJwkPublicKeyNamespace
	}
	var key string
	{
		key = signerJwkPublicKeyKey
	}
	v := &signer.JwkPublicKeyRequest{
		Group:  body.Group,
		Engine: body.Engine,
	}
	{
		var zero string
		if v.Engine == zero {
			v.Engine = "transit"
		}
	}
	v.Namespace = namespace
	v.Key = key

	return v, nil
}

// BuildCredentialProofPayload builds the payload for the signer
// CredentialProof endpoint from CLI flags.
func BuildCredentialProofPayload(signerCredentialProofBody string) (*signer.CredentialProofRequest, error) {
	var err error
	var body CredentialProofRequestBody
	{
		err = json.Unmarshal([]byte(signerCredentialProofBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"credential\": {\n         \"@context\": [\n            \"https://www.w3.org/2018/credentials/v1\",\n            \"https://w3id.org/security/suites/jws-2020/v1\",\n            \"https://schema.org\"\n         ],\n         \"type\": [\n            \"VerifiableCredential\"\n         ],\n         \"issuer\": \"did:web:nginx:policy:policy:example:example:1.0:evaluation\",\n         \"issuanceDate\": \"2010-01-01T19:23:24.651387237Z\",\n         \"credentialSubject\": {\n            \"name\": \"Alice\",\n            \"allow\": true\n         }\n      },\n      \"disclosureFrame\": [\n         \"email\"\n      ],\n      \"format\": \"ldp_vc or vc+sd-jwt\",\n      \"group\": \"Group\",\n      \"key\": \"key1\",\n      \"namespace\": \"transit\",\n      \"nonce\": \"3483492392vvv-fff\",\n      \"signatureType\": \"ed25519signature2020\"\n   }'")
		}
		if body.Credential == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("credential", "body"))
		}
		if !(body.Format == "ldp_vc" || body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
		if !(body.SignatureType == "ed25519signature2020" || body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &signer.CredentialProofRequest{
		Namespace:     body.Namespace,
		Key:           body.Key,
		Credential:    body.Credential,
		Group:         body.Group,
		Format:        body.Format,
		Nonce:         body.Nonce,
		SignatureType: body.SignatureType,
	}
	{
		var zero string
		if v.Format == zero {
			v.Format = "ldp_vc"
		}
	}
	{
		var zero string
		if v.SignatureType == zero {
			v.SignatureType = "jsonwebsignature2020"
		}
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}

	return v, nil
}

// BuildPresentationProofPayload builds the payload for the signer
// PresentationProof endpoint from CLI flags.
func BuildPresentationProofPayload(signerPresentationProofBody string) (*signer.PresentationProofRequest, error) {
	var err error
	var body PresentationProofRequestBody
	{
		err = json.Unmarshal([]byte(signerPresentationProofBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"aud\": \"http://...\",\n      \"disclosureFrame\": [\n         \"email\"\n      ],\n      \"format\": \"ldp_vc or vc+sd-jwt\",\n      \"group\": \"Group\",\n      \"issuer\": \"Aut et aut adipisci voluptatem consectetur quidem.\",\n      \"key\": \"key1\",\n      \"namespace\": \"transit\",\n      \"nonce\": \"3483492392vvv-fff\",\n      \"presentation\": \"Hic doloribus.\",\n      \"signatureType\": \"ed25519signature2020\"\n   }'")
		}
		if body.Presentation == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("presentation", "body"))
		}
		if !(body.SignatureType == "ed25519signature2020" || body.SignatureType == "jsonwebsignature2020" || body.SignatureType == "sdjwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020", "sdjwt"}))
		}
		if !(body.Format == "ldp_vc" || body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &signer.PresentationProofRequest{
		Issuer:        body.Issuer,
		Namespace:     body.Namespace,
		Key:           body.Key,
		Presentation:  body.Presentation,
		Group:         body.Group,
		Nonce:         body.Nonce,
		SignatureType: body.SignatureType,
		Format:        body.Format,
		Aud:           body.Aud,
	}
	{
		var zero string
		if v.SignatureType == zero {
			v.SignatureType = "jsonwebsignature2020"
		}
	}
	{
		var zero string
		if v.Format == zero {
			v.Format = "ldp_vc"
		}
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}

	return v, nil
}

// BuildCreateCredentialPayload builds the payload for the signer
// CreateCredential endpoint from CLI flags.
func BuildCreateCredentialPayload(signerCreateCredentialBody string, signerCreateCredentialXOrigin string) (*signer.CreateCredentialRequest, error) {
	var err error
	var body CreateCredentialRequestBody
	{
		err = json.Unmarshal([]byte(signerCreateCredentialBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": [\n         \"https://w3id.org/security/suites/jws-2020/v1\",\n         \"https://schema.org\"\n      ],\n      \"credentialSubject\": {\n         \"hello\": \"world\"\n      },\n      \"disclosureFrame\": [\n         \"email\"\n      ],\n      \"format\": \"ldp_vc or vc+sd-jwt\",\n      \"group\": \"Group\",\n      \"holder\": \"urn:3333:ddd\",\n      \"issuer\": \"did:web:example.com\",\n      \"key\": \"key1\",\n      \"namespace\": \"transit\",\n      \"nonce\": \"3483492392vvv-fff\",\n      \"signatureType\": \"ed25519signature2020\",\n      \"status\": true,\n      \"type\": [\n         \"VerifiableCredential\",\n         \"TestCredential]\"\n      ]\n   }'")
		}
		if body.CredentialSubject == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("credentialSubject", "body"))
		}
		if !(body.Format == "ldp_vc" || body.Format == "vc+sd-jwt") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.format", body.Format, []any{"ldp_vc", "vc+sd-jwt"}))
		}
		if !(body.SignatureType == "ed25519signature2020" || body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var xOrigin string
	{
		xOrigin = signerCreateCredentialXOrigin
	}
	v := &signer.CreateCredentialRequest{
		Issuer:            body.Issuer,
		Namespace:         body.Namespace,
		Key:               body.Key,
		CredentialSubject: body.CredentialSubject,
		Group:             body.Group,
		Format:            body.Format,
		Nonce:             body.Nonce,
		Status:            body.Status,
		SignatureType:     body.SignatureType,
		Holder:            body.Holder,
	}
	if body.Context != nil {
		v.Context = make([]string, len(body.Context))
		for i, val := range body.Context {
			v.Context[i] = val
		}
	}
	{
		var zero string
		if v.Format == zero {
			v.Format = "ldp_vc"
		}
	}
	{
		var zero string
		if v.SignatureType == zero {
			v.SignatureType = "jsonwebsignature2020"
		}
	}
	if body.Type != nil {
		v.Type = make([]string, len(body.Type))
		for i, val := range body.Type {
			v.Type[i] = val
		}
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XOrigin = xOrigin

	return v, nil
}

// BuildCreatePresentationPayload builds the payload for the signer
// CreatePresentation endpoint from CLI flags.
func BuildCreatePresentationPayload(signerCreatePresentationBody string) (*signer.CreatePresentationRequest, error) {
	var err error
	var body CreatePresentationRequestBody
	{
		err = json.Unmarshal([]byte(signerCreatePresentationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"context\": [\n         \"https://w3id.org/security/suites/jws-2020/v1\",\n         \"https://schema.org\"\n      ],\n      \"data\": [\n         {\n            \"hello\": \"world\"\n         },\n         {\n            \"hola\": \"mundo\"\n         }\n      ],\n      \"group\": \"Group\",\n      \"issuer\": \"did:web:example.com\",\n      \"key\": \"key1\",\n      \"namespace\": \"transit\",\n      \"nonce\": \"3483492392vvv-fff\",\n      \"signatureType\": \"ed25519signature2020\"\n   }'")
		}
		if body.Data == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
		}
		if !(body.SignatureType == "ed25519signature2020" || body.SignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.signatureType", body.SignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
		if err != nil {
			return nil, err
		}
	}
	v := &signer.CreatePresentationRequest{
		Issuer:        body.Issuer,
		Namespace:     body.Namespace,
		Key:           body.Key,
		Group:         body.Group,
		Nonce:         body.Nonce,
		SignatureType: body.SignatureType,
	}
	if body.Data != nil {
		v.Data = make([]any, len(body.Data))
		for i, val := range body.Data {
			v.Data[i] = val
		}
	} else {
		v.Data = []any{}
	}
	if body.Context != nil {
		v.Context = make([]string, len(body.Context))
		for i, val := range body.Context {
			v.Context[i] = val
		}
	}
	{
		var zero string
		if v.SignatureType == zero {
			v.SignatureType = "jsonwebsignature2020"
		}
	}

	return v, nil
}

// BuildVerifyCredentialPayload builds the payload for the signer
// VerifyCredential endpoint from CLI flags.
func BuildVerifyCredentialPayload(signerVerifyCredentialBody string, signerVerifyCredentialXFormat string, signerVerifyCredentialXNamespace string, signerVerifyCredentialXGroup string) (*signer.VerifyCredentialRequest, error) {
	var err error
	var body VerifyCredentialRequestBody
	{
		err = json.Unmarshal([]byte(signerVerifyCredentialBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"credential\": \"RWEgcXVhcyBwcmFlc2VudGl1bSB2b2x1cHRhcyBvY2NhZWNhdGkgZXN0IGZhY2VyZS4=\",\n      \"disclosureFrame\": [\n         \"email\"\n      ]\n   }'")
		}
		if body.Credential == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("credential", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var xFormat string
	{
		if signerVerifyCredentialXFormat != "" {
			xFormat = signerVerifyCredentialXFormat
			if !(xFormat == "ldp_vc" || xFormat == "vc+sd-jwt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("x-format", xFormat, []any{"ldp_vc", "vc+sd-jwt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	var xNamespace *string
	{
		if signerVerifyCredentialXNamespace != "" {
			xNamespace = &signerVerifyCredentialXNamespace
		}
	}
	var xGroup *string
	{
		if signerVerifyCredentialXGroup != "" {
			xGroup = &signerVerifyCredentialXGroup
		}
	}
	v := &signer.VerifyCredentialRequest{
		Credential: body.Credential,
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XFormat = xFormat
	v.XNamespace = xNamespace
	v.XGroup = xGroup

	return v, nil
}

// BuildVerifyPresentationPayload builds the payload for the signer
// VerifyPresentation endpoint from CLI flags.
func BuildVerifyPresentationPayload(signerVerifyPresentationBody string, signerVerifyPresentationXFormat string) (*signer.VerifyPresentationRequest, error) {
	var err error
	var body VerifyPresentationRequestBody
	{
		err = json.Unmarshal([]byte(signerVerifyPresentationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"aud\": \"Sit explicabo possimus ea accusantium.\",\n      \"disclosureFrame\": [\n         \"email\"\n      ],\n      \"nonce\": \"Ut velit.\",\n      \"presentation\": \"RG9sb3JlcyBldCBuZXF1ZSBibGFuZGl0aWlzIG5vc3RydW0gbmloaWwgY29uc2VxdXVudHVyLg==\"\n   }'")
		}
		if body.Presentation == nil {
			err = goa.MergeErrors(err, goa.MissingFieldError("presentation", "body"))
		}
		if err != nil {
			return nil, err
		}
	}
	var xFormat string
	{
		if signerVerifyPresentationXFormat != "" {
			xFormat = signerVerifyPresentationXFormat
			if !(xFormat == "ldp_vc" || xFormat == "vc+sd-jwt") {
				err = goa.MergeErrors(err, goa.InvalidEnumValueError("x-format", xFormat, []any{"ldp_vc", "vc+sd-jwt"}))
			}
			if err != nil {
				return nil, err
			}
		}
	}
	v := &signer.VerifyPresentationRequest{
		Presentation: body.Presentation,
		Aud:          body.Aud,
		Nonce:        body.Nonce,
	}
	if body.DisclosureFrame != nil {
		v.DisclosureFrame = make([]string, len(body.DisclosureFrame))
		for i, val := range body.DisclosureFrame {
			v.DisclosureFrame[i] = val
		}
	}
	v.XFormat = xFormat

	return v, nil
}

// BuildSignPayload builds the payload for the signer Sign endpoint from CLI
// flags.
func BuildSignPayload(signerSignBody string) (*signer.SignRequest, error) {
	var err error
	var body SignRequestBody
	{
		err = json.Unmarshal([]byte(signerSignBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"data\": \"Quis voluptas.\",\n      \"group\": \"Group\",\n      \"key\": \"Vel porro qui quidem unde.\",\n      \"namespace\": \"Molestiae id vitae vel.\"\n   }'")
		}
	}
	v := &signer.SignRequest{
		Namespace: body.Namespace,
		Key:       body.Key,
		Data:      body.Data,
		Group:     body.Group,
	}

	return v, nil
}

// BuildDidDocPayload builds the payload for the signer didDoc endpoint from
// CLI flags.
func BuildDidDocPayload(signerDidDocXNamespace string, signerDidDocXGroup string, signerDidDocXDid string, signerDidDocXEngine string) (*signer.DidRequest, error) {
	var xNamespace string
	{
		if signerDidDocXNamespace != "" {
			xNamespace = signerDidDocXNamespace
		}
	}
	var xGroup string
	{
		if signerDidDocXGroup != "" {
			xGroup = signerDidDocXGroup
		}
	}
	var xDid string
	{
		if signerDidDocXDid != "" {
			xDid = signerDidDocXDid
		}
	}
	var xEngine string
	{
		if signerDidDocXEngine != "" {
			xEngine = signerDidDocXEngine
		}
	}
	v := &signer.DidRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XDid = xDid
	v.XEngine = xEngine

	return v, nil
}

// BuildDidListPayload builds the payload for the signer didList endpoint from
// CLI flags.
func BuildDidListPayload(signerDidListXNamespace string, signerDidListXGroup string, signerDidListXEngine string) (*signer.DidListRequest, error) {
	var xNamespace string
	{
		xNamespace = signerDidListXNamespace
	}
	var xGroup string
	{
		if signerDidListXGroup != "" {
			xGroup = signerDidListXGroup
		}
	}
	var xEngine string
	{
		if signerDidListXEngine != "" {
			xEngine = signerDidListXEngine
		}
	}
	v := &signer.DidListRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XEngine = xEngine

	return v, nil
}

// BuildDidConfigurationPayload builds the payload for the signer
// DidConfiguration endpoint from CLI flags.
func BuildDidConfigurationPayload(signerDidConfigurationBody string, signerDidConfigurationXNamespace string, signerDidConfigurationXGroup string, signerDidConfigurationXOrigin string, signerDidConfigurationXDid string, signerDidConfigurationXNonce string) (*signer.DidConfiguration2, error) {
	var err error
	var body DidConfigurationRequestBody
	{
		err = json.Unmarshal([]byte(signerDidConfigurationBody), &body)
		if err != nil {
			return nil, fmt.Errorf("invalid JSON for body, \nerror: %s, \nexample of valid JSON:\n%s", err, "'{\n      \"x-signatureType\": \"ed25519signature2020\"\n   }'")
		}
		if !(body.XSignatureType == "ed25519signature2020" || body.XSignatureType == "jsonwebsignature2020") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.x-signatureType", body.XSignatureType, []any{"ed25519signature2020", "jsonwebsignature2020"}))
		}
		if err != nil {
			return nil, err
		}
	}
	var xNamespace string
	{
		xNamespace = signerDidConfigurationXNamespace
	}
	var xGroup string
	{
		if signerDidConfigurationXGroup != "" {
			xGroup = signerDidConfigurationXGroup
		}
	}
	var xOrigin string
	{
		xOrigin = signerDidConfigurationXOrigin
	}
	var xDid *string
	{
		if signerDidConfigurationXDid != "" {
			xDid = &signerDidConfigurationXDid
		}
	}
	var xNonce *string
	{
		if signerDidConfigurationXNonce != "" {
			xNonce = &signerDidConfigurationXNonce
		}
	}
	v := &signer.DidConfiguration2{
		XSignatureType: body.XSignatureType,
	}
	{
		var zero string
		if v.XSignatureType == zero {
			v.XSignatureType = "jsonwebsignature2020"
		}
	}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XOrigin = xOrigin
	v.XDid = xDid
	v.XNonce = xNonce

	return v, nil
}

// BuildJwksPayload builds the payload for the signer Jwks endpoint from CLI
// flags.
func BuildJwksPayload(signerJwksXNamespace string, signerJwksXGroup string, signerJwksXEngine string) (*signer.JwksRequest, error) {
	var xNamespace string
	{
		xNamespace = signerJwksXNamespace
	}
	var xGroup *string
	{
		if signerJwksXGroup != "" {
			xGroup = &signerJwksXGroup
		}
	}
	var xEngine string
	{
		if signerJwksXEngine != "" {
			xEngine = signerJwksXEngine
		}
	}
	v := &signer.JwksRequest{}
	v.XNamespace = xNamespace
	v.XGroup = xGroup
	v.XEngine = xEngine

	return v, nil
}
